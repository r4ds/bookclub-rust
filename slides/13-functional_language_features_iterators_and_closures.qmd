---
engine: knitr
title: "13. Functional Language Features: Iterators and Closures"
---

# Learning objectives

::: nonincremental
- Closures
- Iterators
- Improve our I/O program from last chapter
- 'Zero-cost' abstractions
:::

::: notes
- You can add notes on each slide with blocks like this!
- Load a deck in the browser and type "s" to see these notes.
:::

## Functional programming in Rust

- Rust design influnced by functional programming languages like Haskell and Ocaml

- Functional programming:
    - Emphasizes immutability, pure functions, and treating functions as first-class citizens.
    - Focuses on declarative code, leveraging higher-order functions and composition for modularity. 
    - Note that `R` has broad support for functional programming.

# Closures

## Closure Capture Their Environment

- Recall in R, every function is a closure.  

- Functions store their enclosing environment, allowing them to access variables from outside their own scope.

```
example_closure <- function(x) {
    y <- 10
    function() {
        x + y
    }
}

closure_instance <- example_closure(5)
closure_instance()  # Returns 15
```

## Rust closures 

- In Rust, closures that can capture their environment as well. 
- Ordinary functions are *not* closures, and do not capture anything.
- Only anonymous functions can be closures: 

```{rust}
let expensive_closure = |num: u32| -> u32 {
        println!("calculating slowly...");
        thread::sleep(Duration::from_secs(2));
        num
    };
```
- Must do this in a controlled this due to memory safety!
  - "Capture the environment" - Move or Immutable / Mutable reference? 
  - ? 

- 



## SLIDE

# SLIDE SECTION

## SLIDE

## SLIDE
