---
engine: knitr
title: "13. Functional Language Features: Iterators and Closures"
---

# Learning objectives

::: nonincremental
- Closures
- Iterators
- Improve our I/O program from last chapter
- 'Zero-cost' abstractions
:::

::: notes
- You can add notes on each slide with blocks like this!
- Load a deck in the browser and type "s" to see these notes.
:::

## Functional programming

::: nonincremental
Rust design influnced by strongly typed functional programming languages like Haskell and OCaml
:::

> R, at its heart, is a functional language -  *Hadley Wickham, Advanced R* 

- Encorages *Declarative* code, evaluating *expressions* rather of executing *statements*. 

- Builds expressions by applying and composing functions to transform values.

- Treats functions as first-class citizens - they are also values. 

- Emphasizes purity (side effect free functions) and immutability (unchanging values).

## Note

Purity and immutability makes it easier to reason about programs built from expressions without worrying about the evaluation order.


# Closures

## Closure Capture Their Environment

```
example_closure <- function(x) {
    y <- 10
    function() {
        x + y
    }
}

closure_instance <- example_closure(5)
closure_instance()  # Returns 15
```

- In R, every regular function is a closure.  

- Functions store their enclosing environment, allowing them to access variables from outside their own scope.



## Rust closures 

- In Rust, closures that can capture their environment as well. 
- Ordinary functions are *not* closures, and do not capture anything.
- Only anonymous functions can be closures: 

```{rust}
let expensive_closure = |num: u32| -> u32 {
        println!("calculating slowly...");
        thread::sleep(Duration::from_secs(2));
        num
    };
```
- Must do this in a controlled this due to memory safety!
  - "Capture the environment" - Move or Immutable / Mutable reference? 
  - ? 

- 



## SLIDE

# SLIDE SECTION

## SLIDE

## SLIDE
