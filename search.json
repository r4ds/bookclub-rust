[
  {
    "objectID": "slides/19-advanced_features.html#slide",
    "href": "slides/19-advanced_features.html#slide",
    "title": "19. Advanced Features",
    "section": "SLIDE",
    "text": "SLIDE\n\nDENOTE MAJOR SECTIONS WITH # TITLE (eg # Installation)\nADD INDIVIDUAL SLIDES WITH ## (eg ## rustup on Linux/macOS)\nKEEP THEM RELATIVELY SLIDE-LIKE; THESE ARE NOTES, NOT THE BOOK ITSELF.",
    "crumbs": [
      "19. Advanced Features"
    ]
  },
  {
    "objectID": "slides/19-advanced_features.html#slide-1",
    "href": "slides/19-advanced_features.html#slide-1",
    "title": "19. Advanced Features",
    "section": "SLIDE",
    "text": "SLIDE",
    "crumbs": [
      "19. Advanced Features"
    ]
  },
  {
    "objectID": "slides/19-advanced_features.html#slide-2",
    "href": "slides/19-advanced_features.html#slide-2",
    "title": "19. Advanced Features",
    "section": "SLIDE",
    "text": "SLIDE",
    "crumbs": [
      "19. Advanced Features"
    ]
  },
  {
    "objectID": "slides/19-advanced_features.html#slide-3",
    "href": "slides/19-advanced_features.html#slide-3",
    "title": "19. Advanced Features",
    "section": "SLIDE",
    "text": "SLIDE",
    "crumbs": [
      "19. Advanced Features"
    ]
  },
  {
    "objectID": "slides/18-patterns_and_matching.html#slide",
    "href": "slides/18-patterns_and_matching.html#slide",
    "title": "18. Patterns and Matching",
    "section": "SLIDE",
    "text": "SLIDE\n\nDENOTE MAJOR SECTIONS WITH # TITLE (eg # Installation)\nADD INDIVIDUAL SLIDES WITH ## (eg ## rustup on Linux/macOS)\nKEEP THEM RELATIVELY SLIDE-LIKE; THESE ARE NOTES, NOT THE BOOK ITSELF.",
    "crumbs": [
      "18. Patterns and Matching"
    ]
  },
  {
    "objectID": "slides/18-patterns_and_matching.html#slide-1",
    "href": "slides/18-patterns_and_matching.html#slide-1",
    "title": "18. Patterns and Matching",
    "section": "SLIDE",
    "text": "SLIDE",
    "crumbs": [
      "18. Patterns and Matching"
    ]
  },
  {
    "objectID": "slides/18-patterns_and_matching.html#slide-2",
    "href": "slides/18-patterns_and_matching.html#slide-2",
    "title": "18. Patterns and Matching",
    "section": "SLIDE",
    "text": "SLIDE",
    "crumbs": [
      "18. Patterns and Matching"
    ]
  },
  {
    "objectID": "slides/18-patterns_and_matching.html#slide-3",
    "href": "slides/18-patterns_and_matching.html#slide-3",
    "title": "18. Patterns and Matching",
    "section": "SLIDE",
    "text": "SLIDE",
    "crumbs": [
      "18. Patterns and Matching"
    ]
  },
  {
    "objectID": "slides/17-object_oriented_programming_features_of_rust.html#objects-contain-data-and-behavior",
    "href": "slides/17-object_oriented_programming_features_of_rust.html#objects-contain-data-and-behavior",
    "title": "17. Object Oriented Programming Features of Rust",
    "section": "Objects Contain Data and Behavior",
    "text": "Objects Contain Data and Behavior\n\nUsing this definition, Rust is object-oriented: structs and enums have data, and impl blocks provide methods on structs and enums. Even though structs and enums with methods aren’t called objects, they provide the same functionality, according to the Gang of Four’s definition of objects.",
    "crumbs": [
      "17. Object Oriented Programming Features of Rust"
    ]
  },
  {
    "objectID": "slides/17-object_oriented_programming_features_of_rust.html#encapsulation-that-hides-implementation-details",
    "href": "slides/17-object_oriented_programming_features_of_rust.html#encapsulation-that-hides-implementation-details",
    "title": "17. Object Oriented Programming Features of Rust",
    "section": "Encapsulation that Hides Implementation Details",
    "text": "Encapsulation that Hides Implementation Details\n\nIf encapsulation is a required aspect for a language to be considered object-oriented, then Rust meets that requirement. The option to use pub or not for different parts of code enables encapsulation of implementation details.",
    "crumbs": [
      "17. Object Oriented Programming Features of Rust"
    ]
  },
  {
    "objectID": "slides/17-object_oriented_programming_features_of_rust.html#inheritance-as-a-type-system-and-as-code-sharing",
    "href": "slides/17-object_oriented_programming_features_of_rust.html#inheritance-as-a-type-system-and-as-code-sharing",
    "title": "17. Object Oriented Programming Features of Rust",
    "section": "Inheritance as a Type System and as Code Sharing",
    "text": "Inheritance as a Type System and as Code Sharing\n\nIf a language must have inheritance to be an object-oriented language, then Rust is not one. There is no way to define a struct that inherits the parent struct’s fields and method implementations without using a macro.\n\n\nHowever, if you’re used to having inheritance in your programming toolbox, you can use other solutions in Rust, depending on your reason for reaching for inheritance in the first place.",
    "crumbs": [
      "17. Object Oriented Programming Features of Rust"
    ]
  },
  {
    "objectID": "slides/17-object_oriented_programming_features_of_rust.html#polymorphism-and-inheritance",
    "href": "slides/17-object_oriented_programming_features_of_rust.html#polymorphism-and-inheritance",
    "title": "17. Object Oriented Programming Features of Rust",
    "section": "Polymorphism and inheritance",
    "text": "Polymorphism and inheritance\n\nRust instead uses generics to abstract over different possible types and trait bounds to impose constraints on what those types must provide. This is sometimes called bounded parametric polymorphism.",
    "crumbs": [
      "17. Object Oriented Programming Features of Rust"
    ]
  },
  {
    "objectID": "slides/17-object_oriented_programming_features_of_rust.html#section",
    "href": "slides/17-object_oriented_programming_features_of_rust.html#section",
    "title": "17. Object Oriented Programming Features of Rust",
    "section": "",
    "text": "trait Sound {\n    fn make_sound(&self);\n}",
    "crumbs": [
      "17. Object Oriented Programming Features of Rust"
    ]
  },
  {
    "objectID": "slides/17-object_oriented_programming_features_of_rust.html#section-1",
    "href": "slides/17-object_oriented_programming_features_of_rust.html#section-1",
    "title": "17. Object Oriented Programming Features of Rust",
    "section": "",
    "text": "use blog::Post;\n\nfn main() {\n    let mut post = Post::new();\n\n    post.add_text(\"I ate a salad for lunch today\");\n    assert_eq!(\"\", post.content());\n\n    post.request_review();\n    assert_eq!(\"\", post.content());\n\n    post.approve();\n    assert_eq!(\"I ate a salad for lunch today\", post.content());\n}",
    "crumbs": [
      "17. Object Oriented Programming Features of Rust"
    ]
  },
  {
    "objectID": "slides/04-understanding_ownership.html#learning-objectives-1",
    "href": "slides/04-understanding_ownership.html#learning-objectives-1",
    "title": "4. Understanding Ownership",
    "section": "Learning objectives",
    "text": "Learning objectives\n\nUnderstand Rust’s ownership system\nWork with the borrow checker\nImplement the right ownership model at the right time",
    "crumbs": [
      "4. Understanding Ownership"
    ]
  },
  {
    "objectID": "slides/04-understanding_ownership.html#moves",
    "href": "slides/04-understanding_ownership.html#moves",
    "title": "4. Understanding Ownership",
    "section": "Moves",
    "text": "Moves\nlet x = String::from(\"hello\");\nlet x2 = x;\nprintln!(\"{x}\");",
    "crumbs": [
      "4. Understanding Ownership"
    ]
  },
  {
    "objectID": "slides/04-understanding_ownership.html#moves-1",
    "href": "slides/04-understanding_ownership.html#moves-1",
    "title": "4. Understanding Ownership",
    "section": "Moves",
    "text": "Moves\nlet x = String::from(\"hello\");\ntake_ownership(x);\nprintln!(\"{x}\");\n\nfn take_ownership(_name: String) {\n  ()\n}",
    "crumbs": [
      "4. Understanding Ownership"
    ]
  },
  {
    "objectID": "slides/04-understanding_ownership.html#moves-2",
    "href": "slides/04-understanding_ownership.html#moves-2",
    "title": "4. Understanding Ownership",
    "section": "Moves",
    "text": "Moves\nlet x = String::from(\"hello\");\ntake_ownership(x.clone());\nprintln!(\"{x}\");\n\nfn take_ownership(_name: String) {\n  ()\n}",
    "crumbs": [
      "4. Understanding Ownership"
    ]
  },
  {
    "objectID": "slides/04-understanding_ownership.html#moves-3",
    "href": "slides/04-understanding_ownership.html#moves-3",
    "title": "4. Understanding Ownership",
    "section": "Moves",
    "text": "Moves",
    "crumbs": [
      "4. Understanding Ownership"
    ]
  },
  {
    "objectID": "slides/04-understanding_ownership.html#stack-vs-heap",
    "href": "slides/04-understanding_ownership.html#stack-vs-heap",
    "title": "4. Understanding Ownership",
    "section": "Stack vs Heap",
    "text": "Stack vs Heap\nlet x = 1;\nprintln!(\"{x}\");\nprintln!(\"{x}\");",
    "crumbs": [
      "4. Understanding Ownership"
    ]
  },
  {
    "objectID": "slides/04-understanding_ownership.html#stack",
    "href": "slides/04-understanding_ownership.html#stack",
    "title": "4. Understanding Ownership",
    "section": "Stack",
    "text": "Stack",
    "crumbs": [
      "4. Understanding Ownership"
    ]
  },
  {
    "objectID": "slides/04-understanding_ownership.html#heap",
    "href": "slides/04-understanding_ownership.html#heap",
    "title": "4. Understanding Ownership",
    "section": "Heap",
    "text": "Heap",
    "crumbs": [
      "4. Understanding Ownership"
    ]
  },
  {
    "objectID": "slides/04-understanding_ownership.html#boxnew",
    "href": "slides/04-understanding_ownership.html#boxnew",
    "title": "4. Understanding Ownership",
    "section": "Box::new()",
    "text": "Box::new()\nlet x = Box::new(1);\ntake_ownership(x);\nprintln!(\"{x}\");\n\nfn take_ownership(_name: Box&lt;i32&gt;) {\n  ()\n}",
    "crumbs": [
      "4. Understanding Ownership"
    ]
  },
  {
    "objectID": "slides/04-understanding_ownership.html#boxnew-1",
    "href": "slides/04-understanding_ownership.html#boxnew-1",
    "title": "4. Understanding Ownership",
    "section": "Box::new()",
    "text": "Box::new()",
    "crumbs": [
      "4. Understanding Ownership"
    ]
  },
  {
    "objectID": "slides/04-understanding_ownership.html#immutable-references",
    "href": "slides/04-understanding_ownership.html#immutable-references",
    "title": "4. Understanding Ownership",
    "section": "Immutable references",
    "text": "Immutable references\nlet x = String::from(\"hello\");\nborrow(&x);\nprintln!(\"{x}\");\n\nfn borrow(_name: &String) {\n  ()\n}",
    "crumbs": [
      "4. Understanding Ownership"
    ]
  },
  {
    "objectID": "slides/04-understanding_ownership.html#immutable-references-1",
    "href": "slides/04-understanding_ownership.html#immutable-references-1",
    "title": "4. Understanding Ownership",
    "section": "Immutable references",
    "text": "Immutable references",
    "crumbs": [
      "4. Understanding Ownership"
    ]
  },
  {
    "objectID": "slides/04-understanding_ownership.html#immutable-references-2",
    "href": "slides/04-understanding_ownership.html#immutable-references-2",
    "title": "4. Understanding Ownership",
    "section": "Immutable references",
    "text": "Immutable references",
    "crumbs": [
      "4. Understanding Ownership"
    ]
  },
  {
    "objectID": "slides/04-understanding_ownership.html#immutable-references-3",
    "href": "slides/04-understanding_ownership.html#immutable-references-3",
    "title": "4. Understanding Ownership",
    "section": "Immutable references",
    "text": "Immutable references\nlet x = String::from(\"hello\");\nlet x2 = &x;\n\nborrow(&x);\nprintln!(\"{x2}\");\n\nfn borrow(_name: &String) {\n  ()\n}",
    "crumbs": [
      "4. Understanding Ownership"
    ]
  },
  {
    "objectID": "slides/04-understanding_ownership.html#immutable-references-4",
    "href": "slides/04-understanding_ownership.html#immutable-references-4",
    "title": "4. Understanding Ownership",
    "section": "Immutable references",
    "text": "Immutable references",
    "crumbs": [
      "4. Understanding Ownership"
    ]
  },
  {
    "objectID": "slides/04-understanding_ownership.html#mutable-references",
    "href": "slides/04-understanding_ownership.html#mutable-references",
    "title": "4. Understanding Ownership",
    "section": "Mutable references",
    "text": "Mutable references\nlet mut x = String::from(\"hello\");\n\nlet x2 = &x;\n\nborrow(&mut x);\n\nprintln!(\"{x2}\");\n\nfn borrow(_name: &mut String) {\n  ()\n}",
    "crumbs": [
      "4. Understanding Ownership"
    ]
  },
  {
    "objectID": "slides/04-understanding_ownership.html#mutable-references-1",
    "href": "slides/04-understanding_ownership.html#mutable-references-1",
    "title": "4. Understanding Ownership",
    "section": "Mutable references",
    "text": "Mutable references",
    "crumbs": [
      "4. Understanding Ownership"
    ]
  },
  {
    "objectID": "slides/04-understanding_ownership.html#slices",
    "href": "slides/04-understanding_ownership.html#slices",
    "title": "4. Understanding Ownership",
    "section": "Slices",
    "text": "Slices",
    "crumbs": [
      "4. Understanding Ownership"
    ]
  },
  {
    "objectID": "slides/04-understanding_ownership.html#string-literals-are-slices",
    "href": "slides/04-understanding_ownership.html#string-literals-are-slices",
    "title": "4. Understanding Ownership",
    "section": "String literals are slices",
    "text": "String literals are slices\nlet hello = \"hello\";\nthere(hello);\n\nfn there(hello2: &str) {\n  println!(\"{hello2} there\")\n}",
    "crumbs": [
      "4. Understanding Ownership"
    ]
  },
  {
    "objectID": "slides/04-understanding_ownership.html#str-as-parameters",
    "href": "slides/04-understanding_ownership.html#str-as-parameters",
    "title": "4. Understanding Ownership",
    "section": "&str as parameters",
    "text": "&str as parameters\nlet hello = String::from(\"hello\");\nthere(&hello);\n\nfn there(hello2: &str) {\n  println!(\"{hello2} there\")\n}",
    "crumbs": [
      "4. Understanding Ownership"
    ]
  },
  {
    "objectID": "slides/02-programming_a_guessing_game.html#create-the-new-project",
    "href": "slides/02-programming_a_guessing_game.html#create-the-new-project",
    "title": "2. Programming a Guessing Game",
    "section": "Create the new Project",
    "text": "Create the new Project\n$ cargo new guessing_game\n$ cd guessing_game\n\nrecall, cargo is Rust’s package manager and build tool\ncargo new creates a new project with the given name\nby default, this creates a “Hello World” program",
    "crumbs": [
      "2. Programming a Guessing Game"
    ]
  },
  {
    "objectID": "slides/02-programming_a_guessing_game.html#compile-and-run-it",
    "href": "slides/02-programming_a_guessing_game.html#compile-and-run-it",
    "title": "2. Programming a Guessing Game",
    "section": "Compile and run it",
    "text": "Compile and run it\n$ cargo run\n\ncargo run both compiles and runs the project\nyou should see “Hello, world!” output to your console\nyou can also just compile with cargo build",
    "crumbs": [
      "2. Programming a Guessing Game"
    ]
  },
  {
    "objectID": "slides/02-programming_a_guessing_game.html#storing-values-with-variables",
    "href": "slides/02-programming_a_guessing_game.html#storing-values-with-variables",
    "title": "2. Programming a Guessing Game",
    "section": "Storing Values with Variables",
    "text": "Storing Values with Variables\nlet mut guess = String::new();\n\nadd this to the main function in src/main.rs\nuse let to create variables\nvariables are immutable by default\nuse let mut for mutable variable",
    "crumbs": [
      "2. Programming a Guessing Game"
    ]
  },
  {
    "objectID": "slides/02-programming_a_guessing_game.html#receiving-user-input",
    "href": "slides/02-programming_a_guessing_game.html#receiving-user-input",
    "title": "2. Programming a Guessing Game",
    "section": "Receiving User Input",
    "text": "Receiving User Input\nuse std::io;\n// ...\nprintln!(\"Please input your guess.\");\nio::stdin().read_line(&mut guess);\n\ncall stdin().read_line(&mut guess) to get user input\ninput is appended to the empty guess string\n& indicates a reference to the variable\n&mut is necessary, because references are immutable by default",
    "crumbs": [
      "2. Programming a Guessing Game"
    ]
  },
  {
    "objectID": "slides/02-programming_a_guessing_game.html#handling-potential-failure-with-result",
    "href": "slides/02-programming_a_guessing_game.html#handling-potential-failure-with-result",
    "title": "2. Programming a Guessing Game",
    "section": "Handling Potential Failure with Result",
    "text": "Handling Potential Failure with Result\nio::stdin()\n    .read_line(&mut guess)\n    .expect(\"Failed to read line\");\n\nread_line returns a Result type (either Ok or Err)\nuse .expect() to handle errors and crash if an error occurs",
    "crumbs": [
      "2. Programming a Guessing Game"
    ]
  },
  {
    "objectID": "slides/02-programming_a_guessing_game.html#printing-values-with-println",
    "href": "slides/02-programming_a_guessing_game.html#printing-values-with-println",
    "title": "2. Programming a Guessing Game",
    "section": "Printing Values with println!",
    "text": "Printing Values with println!\nprintln!(\"You guessed: {guess}\");\n\nuse println! with placeholders ({}) for formatted output\ncombines user input and text in one statement",
    "crumbs": [
      "2. Programming a Guessing Game"
    ]
  },
  {
    "objectID": "slides/02-programming_a_guessing_game.html#testing-the-first-part",
    "href": "slides/02-programming_a_guessing_game.html#testing-the-first-part",
    "title": "2. Programming a Guessing Game",
    "section": "Testing the First Part",
    "text": "Testing the First Part\n$ cargo run\n\nprogram now accepts input and prints the guess\ntest by entering values to see the output",
    "crumbs": [
      "2. Programming a Guessing Game"
    ]
  },
  {
    "objectID": "slides/02-programming_a_guessing_game.html#code-checkpoint-1",
    "href": "slides/02-programming_a_guessing_game.html#code-checkpoint-1",
    "title": "2. Programming a Guessing Game",
    "section": "Code checkpoint 1",
    "text": "Code checkpoint 1\nuse std::io;\n\nfn main() {\n    let mut guess = String::new();\n    println!(\"Please input your guess.\");\n    io::stdin()\n        .read_line(&mut guess)\n        .expect(\"Failed to read line\");\n\n    println!(\"You guessed: {}\", guess);\n}",
    "crumbs": [
      "2. Programming a Guessing Game"
    ]
  },
  {
    "objectID": "slides/02-programming_a_guessing_game.html#using-a-crate-to-get-more-functionality",
    "href": "slides/02-programming_a_guessing_game.html#using-a-crate-to-get-more-functionality",
    "title": "2. Programming a Guessing Game",
    "section": "Using a Crate to Get More Functionality",
    "text": "Using a Crate to Get More Functionality\n[dependencies]\nrand = \"0.8.5\"\n\nadd the rand crate to Cargo.toml under [dependencies]\ncargo build will fetch and compile external dependencies\nyou can also use cargo add to add dependencies\n\ne.g. cargo add rand",
    "crumbs": [
      "2. Programming a Guessing Game"
    ]
  },
  {
    "objectID": "slides/02-programming_a_guessing_game.html#generating-a-random-number",
    "href": "slides/02-programming_a_guessing_game.html#generating-a-random-number",
    "title": "2. Programming a Guessing Game",
    "section": "Generating a Random Number",
    "text": "Generating a Random Number\nuse rand::Rng;\nlet secret_number = rand::thread_rng().gen_range(1..=100);\n\nthis code should now compile\nuse rand::Rng; brings the random number generator trait (Rng) into scope\nuse thread_rng() for random number generation",
    "crumbs": [
      "2. Programming a Guessing Game"
    ]
  },
  {
    "objectID": "slides/02-programming_a_guessing_game.html#matching-the-guess-to-the-secret-number",
    "href": "slides/02-programming_a_guessing_game.html#matching-the-guess-to-the-secret-number",
    "title": "2. Programming a Guessing Game",
    "section": "Matching the Guess to the Secret Number",
    "text": "Matching the Guess to the Secret Number\nuse std::cmp::Ordering;\nmatch guess.cmp(&secret_number) {\n    Ordering::Less =&gt; println!(\"Too small!\"),\n    Ordering::Greater =&gt; println!(\"Too big!\"),\n    Ordering::Equal =&gt; println!(\"You win!\"),\n}\n\nuse cmp() from the standard library to compare guess with secret_number\ncmp() returns the Ordering enum, which has values (Less, Greater, or Equal)\nmatch will match the appropriate arm of the enum, and print “Too small”, “Too big”, or “You win!”",
    "crumbs": [
      "2. Programming a Guessing Game"
    ]
  },
  {
    "objectID": "slides/02-programming_a_guessing_game.html#parsing-a-string-into-a-number",
    "href": "slides/02-programming_a_guessing_game.html#parsing-a-string-into-a-number",
    "title": "2. Programming a Guessing Game",
    "section": "Parsing a String into a Number",
    "text": "Parsing a String into a Number\nlet guess: u32 = guess.trim().parse().expect(\"Please type a number!\");\n\nguess is a string, but we want to compare it to an integer\nuse trim() to remove unexpected whitespace from the string\nuse parse() to convert the string to an integer\nthis code should now compile",
    "crumbs": [
      "2. Programming a Guessing Game"
    ]
  },
  {
    "objectID": "slides/02-programming_a_guessing_game.html#code-checkpoint-2",
    "href": "slides/02-programming_a_guessing_game.html#code-checkpoint-2",
    "title": "2. Programming a Guessing Game",
    "section": "Code Checkpoint 2",
    "text": "Code Checkpoint 2\nuse rand::Rng;\nuse std::{cmp::Ordering, io};\n\nfn main() {\n    let secret_number = rand::thread_rng().gen_range(1..=100);\n    let mut guess = String::new();\n\n    io::stdin()\n        .read_line(&mut guess)\n        .expect(\"Failed to read line\");\n\n    let guess: u32 = guess.trim().parse().expect(\"Please type a number!\");\n\n    println!(\"You guessed: {}\", guess);\n\n    match guess.cmp(&secret_number) {\n        Ordering::Less =&gt; println!(\"Too small!\"),\n        Ordering::Greater =&gt; println!(\"Too big!\"),\n        Ordering::Equal =&gt; println!(\"You win!\"),\n    }\n}",
    "crumbs": [
      "2. Programming a Guessing Game"
    ]
  },
  {
    "objectID": "slides/02-programming_a_guessing_game.html#quitting-after-a-correct-guess",
    "href": "slides/02-programming_a_guessing_game.html#quitting-after-a-correct-guess",
    "title": "2. Programming a Guessing Game",
    "section": "Quitting After a Correct Guess",
    "text": "Quitting After a Correct Guess\nOrdering::Equal =&gt; {\n    println!(\"You win!\");\n    break;\n}\n\nwe can add additional logic to the Equal branch of the enum using {}\nadd a break statement to exit the loop when the guess is correct\nbreak exits both the loop and the program",
    "crumbs": [
      "2. Programming a Guessing Game"
    ]
  },
  {
    "objectID": "slides/02-programming_a_guessing_game.html#handling-invalid-input",
    "href": "slides/02-programming_a_guessing_game.html#handling-invalid-input",
    "title": "2. Programming a Guessing Game",
    "section": "Handling Invalid Input",
    "text": "Handling Invalid Input\nlet guess: u32 = match guess.trim().parse() {\n    Ok(num) =&gt; num,\n    Err(_) =&gt; continue,\n};\n\ncurrently, we crash on an error by using .expect()\nwe could instead handle the error, by matching the Err enum\nreplace .expect() with match to handle possibility of non-numeric input\nif parsing fails (Err), ignore the guess and continue looping",
    "crumbs": [
      "2. Programming a Guessing Game"
    ]
  },
  {
    "objectID": "slides/02-programming_a_guessing_game.html#final-code-checkpoint",
    "href": "slides/02-programming_a_guessing_game.html#final-code-checkpoint",
    "title": "2. Programming a Guessing Game",
    "section": "Final Code Checkpoint",
    "text": "Final Code Checkpoint\nuse rand::Rng;\nuse std::{cmp::Ordering, io};\n\nfn main() {\n    let secret_number = rand::thread_rng().gen_range(1..=100);\n\n    loop {\n        println!(\"Please input your guess.\");\n\n        let mut guess = String::new();\n        io::stdin()\n            .read_line(&mut guess)\n            .expect(\"Failed to read line\");\n\n        let guess: u32 = match guess.trim().parse() {\n            Ok(num) =&gt; num,\n            Err(_) =&gt; continue,\n        };\n\n        println!(\"You guessed: {}\", guess);\n\n        match guess.cmp(&secret_number) {\n            Ordering::Less =&gt; println!(\"Too small!\"),\n            Ordering::Greater =&gt; println!(\"Too big!\"),\n            Ordering::Equal =&gt; {\n                println!(\"You win!\");\n                break;\n            }\n        }\n    }\n}",
    "crumbs": [
      "2. Programming a Guessing Game"
    ]
  },
  {
    "objectID": "slides/10-generic_types_traits_and_lifetimes.html#generic-functions",
    "href": "slides/10-generic_types_traits_and_lifetimes.html#generic-functions",
    "title": "10. Generic Types, Traits, and Lifetimes",
    "section": "Generic functions",
    "text": "Generic functions\nfn swap_yummy_seeds(seeds: (&str, &str)) -&gt; (&str, &str) {\n    (seeds.1, seeds.0)\n}\n\nfn swap_random_seeds(seeds: (i32, i32)) -&gt; (i32, i32) {\n    (seeds.1, seeds.0)\n}",
    "crumbs": [
      "10. Generic Types, Traits, and Lifetimes"
    ]
  },
  {
    "objectID": "slides/10-generic_types_traits_and_lifetimes.html#generic-functions-1",
    "href": "slides/10-generic_types_traits_and_lifetimes.html#generic-functions-1",
    "title": "10. Generic Types, Traits, and Lifetimes",
    "section": "Generic functions",
    "text": "Generic functions\nfn main() {\n    let yummy_seeds = (\"sunflower\", \"pumpkin\");\n    let random_seeds = (42, 1234);\n\n    println!(\"Before swapping:\");\n    println!(\"{} then {}\", yummy_seeds.0, yummy_seeds.1);\n    println!(\"{} then {}\", random_seeds.0, random_seeds.1);\n\n    // Swap their seeds using the type-specific functions\n    let yummy_seeds = swap_yummy_seeds(yummy_seeds);\n    let random_seeds = swap_random_seeds(random_seeds);\n\n    println!(\"\\nAfter swapping:\");\n    println!(\"{} then {}\", yummy_seeds.0, yummy_seeds.1);\n    println!(\"{} then {}\", random_seeds.0, random_seeds.1);\n}",
    "crumbs": [
      "10. Generic Types, Traits, and Lifetimes"
    ]
  },
  {
    "objectID": "slides/10-generic_types_traits_and_lifetimes.html#generic-functions-2",
    "href": "slides/10-generic_types_traits_and_lifetimes.html#generic-functions-2",
    "title": "10. Generic Types, Traits, and Lifetimes",
    "section": "Generic functions",
    "text": "Generic functions\nfn swap_seeds&lt;T&gt;(seeds: (T, T)) -&gt; (T, T) {\n    (seeds.1, seeds.0)\n}",
    "crumbs": [
      "10. Generic Types, Traits, and Lifetimes"
    ]
  },
  {
    "objectID": "slides/10-generic_types_traits_and_lifetimes.html#generic-functions-3",
    "href": "slides/10-generic_types_traits_and_lifetimes.html#generic-functions-3",
    "title": "10. Generic Types, Traits, and Lifetimes",
    "section": "Generic functions",
    "text": "Generic functions\nfn main() {\n    let yummy_seeds = (\"sunflower\", \"pumpkin\");\n    let random_seeds = (42, 1234);\n\n    println!(\"Before swapping:\");\n    println!(\"{} then {}\", yummy_seeds.0, yummy_seeds.1);\n    println!(\"{} then {}\", random_seeds.0, random_seeds.1);\n\n    // Swap their habitats\n    let yummy_seeds = swap_seeds(yummy_seeds);\n    let random_seeds = swap_seeds(random_seeds);\n\n    println!(\"\\nAfter swapping:\");\n    println!(\"{} then {}\", yummy_seeds.0, yummy_seeds.1);\n    println!(\"{} then {}\", random_seeds.0, random_seeds.1);\n}",
    "crumbs": [
      "10. Generic Types, Traits, and Lifetimes"
    ]
  },
  {
    "objectID": "slides/10-generic_types_traits_and_lifetimes.html#more-types",
    "href": "slides/10-generic_types_traits_and_lifetimes.html#more-types",
    "title": "10. Generic Types, Traits, and Lifetimes",
    "section": "More Types",
    "text": "More Types\nfn swap_animals&lt;T, U&gt;(animal1: (T, T), animal2: (U, U)) -&gt; ((T, U), (U, T)) {\n    // Swap the habitats of the animals\n    ((animal1.0, animal2.1), (animal2.0, animal1.1))\n}",
    "crumbs": [
      "10. Generic Types, Traits, and Lifetimes"
    ]
  },
  {
    "objectID": "slides/10-generic_types_traits_and_lifetimes.html#more-types-1",
    "href": "slides/10-generic_types_traits_and_lifetimes.html#more-types-1",
    "title": "10. Generic Types, Traits, and Lifetimes",
    "section": "More Types",
    "text": "More Types\n\nfn main() {\n    // Define two animals and their habitats\n    let bird = (\"Robin\", \"Forest\");\n    let bat = (\"Fruit Bat\".to_string(), \"Cave\".to_string());\n\n    println!(\"Before swapping:\");\n    println!(\"{} lives in the {}\", bird.0, bird.1);\n    println!(\"{} lives in the {}\", bat.0, bat.1);\n\n    // Swap their habitats\n    let (swapped_bird, swapped_bat) = swap_animals(bird, bat);\n\n    println!(\"\\nAfter swapping:\");\n    println!(\"{} now lives in the {}\", swapped_bird.0, swapped_bird.1);\n    println!(\"{} now lives in the {}\", swapped_bat.0, swapped_bat.1);\n}",
    "crumbs": [
      "10. Generic Types, Traits, and Lifetimes"
    ]
  },
  {
    "objectID": "slides/10-generic_types_traits_and_lifetimes.html#structs-and-generics",
    "href": "slides/10-generic_types_traits_and_lifetimes.html#structs-and-generics",
    "title": "10. Generic Types, Traits, and Lifetimes",
    "section": "Structs and generics",
    "text": "Structs and generics\nstruct Animal&lt;T&gt; {\n    name: String,\n    id: T,\n}",
    "crumbs": [
      "10. Generic Types, Traits, and Lifetimes"
    ]
  },
  {
    "objectID": "slides/10-generic_types_traits_and_lifetimes.html#structs-and-generics-1",
    "href": "slides/10-generic_types_traits_and_lifetimes.html#structs-and-generics-1",
    "title": "10. Generic Types, Traits, and Lifetimes",
    "section": "Structs and generics",
    "text": "Structs and generics\nfn main() {\n    // Animal with a numeric ID\n    let chimpanzee = Animal {\n        name: String::from(\"Chimpanzee\"),\n        id: 23,\n    };\n\n    // Animal with a string ID\n    let bonobo = Animal {\n        name: String::from(\"Bonobo\"),\n        id: String::from(\"A-34\"),\n    };\n\n    println!(\"{} {}\", chimpanzee.name, chimpanzee.id);\n    println!(\"{} {}\", bonobo.name, bonobo.id);\n}",
    "crumbs": [
      "10. Generic Types, Traits, and Lifetimes"
    ]
  },
  {
    "objectID": "slides/10-generic_types_traits_and_lifetimes.html#traits-1",
    "href": "slides/10-generic_types_traits_and_lifetimes.html#traits-1",
    "title": "10. Generic Types, Traits, and Lifetimes",
    "section": "Traits",
    "text": "Traits\nstruct Bird {\n    name: String,\n    wingspan: u8, // Wingspan in cm\n}",
    "crumbs": [
      "10. Generic Types, Traits, and Lifetimes"
    ]
  },
  {
    "objectID": "slides/10-generic_types_traits_and_lifetimes.html#traits-2",
    "href": "slides/10-generic_types_traits_and_lifetimes.html#traits-2",
    "title": "10. Generic Types, Traits, and Lifetimes",
    "section": "Traits",
    "text": "Traits\nuse std::fmt;\nimpl fmt::Display for Bird {\n    fn fmt(&self, f: &mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {\n        // \"Draw\" the bird with its wingspan\n        let wing = \"-\".repeat(self.wingspan as usize / 2); // Half for each wing\n        let drawing = format!(\"{}&lt;{}&gt;{}\", wing, self.name, wing);\n        write!(f, \"{}\", drawing)\n    }\n}",
    "crumbs": [
      "10. Generic Types, Traits, and Lifetimes"
    ]
  },
  {
    "objectID": "slides/10-generic_types_traits_and_lifetimes.html#traits-3",
    "href": "slides/10-generic_types_traits_and_lifetimes.html#traits-3",
    "title": "10. Generic Types, Traits, and Lifetimes",
    "section": "Traits",
    "text": "Traits\nfn main() {\n    let bird = Bird {\n        name: \"Robin\".to_string(),\n        wingspan: 20,\n    };\n\n    let eagle = Bird {\n        name: \"Eagle\".to_string(),\n        wingspan: 60,\n    };\n\n    println!(\"Birds:\");\n    println!(\"{}\", bird);\n    println!(\"{}\", eagle);\n}",
    "crumbs": [
      "10. Generic Types, Traits, and Lifetimes"
    ]
  },
  {
    "objectID": "slides/10-generic_types_traits_and_lifetimes.html#custom-traits-and-generics",
    "href": "slides/10-generic_types_traits_and_lifetimes.html#custom-traits-and-generics",
    "title": "10. Generic Types, Traits, and Lifetimes",
    "section": "Custom traits and generics",
    "text": "Custom traits and generics\ntrait Fly {\n    fn fly(&self) -&gt; String;\n}\n\ntrait LayEggs {\n    fn lay_eggs(&self) -&gt; String;\n}",
    "crumbs": [
      "10. Generic Types, Traits, and Lifetimes"
    ]
  },
  {
    "objectID": "slides/10-generic_types_traits_and_lifetimes.html#custom-traits-and-generics-1",
    "href": "slides/10-generic_types_traits_and_lifetimes.html#custom-traits-and-generics-1",
    "title": "10. Generic Types, Traits, and Lifetimes",
    "section": "Custom traits and generics",
    "text": "Custom traits and generics\nstruct Bird {\n    name: String,\n    wingspan: u8,\n}\n\nimpl Fly for Bird {\n    fn fly(&self) -&gt; String {\n        format!(\n            \"{} flaps its wings (wingspan: {} cm) and soars gracefully!\",\n            self.name, self.wingspan\n        )\n    }\n}\n\nimpl LayEggs for Bird {\n    fn lay_eggs(&self) -&gt; String {\n        format!(\"{} lays eggs in its cozy nest!\", self.name)\n    }\n}",
    "crumbs": [
      "10. Generic Types, Traits, and Lifetimes"
    ]
  },
  {
    "objectID": "slides/10-generic_types_traits_and_lifetimes.html#custom-traits-and-generics-2",
    "href": "slides/10-generic_types_traits_and_lifetimes.html#custom-traits-and-generics-2",
    "title": "10. Generic Types, Traits, and Lifetimes",
    "section": "Custom traits and generics",
    "text": "Custom traits and generics\nstruct Bat {\n    name: String,\n    wingspan: u8,\n}\n\nimpl Fly for Bat {\n    fn fly(&self) -&gt; String {\n        format!(\n            \"{} flies by rapidly flapping its leathery wings (wingspan: {} cm)!\",\n            self.name, self.wingspan\n        )\n    }\n}",
    "crumbs": [
      "10. Generic Types, Traits, and Lifetimes"
    ]
  },
  {
    "objectID": "slides/10-generic_types_traits_and_lifetimes.html#custom-traits-and-generics-3",
    "href": "slides/10-generic_types_traits_and_lifetimes.html#custom-traits-and-generics-3",
    "title": "10. Generic Types, Traits, and Lifetimes",
    "section": "Custom traits and generics",
    "text": "Custom traits and generics\nfn fly_home&lt;T: Fly&gt;(animal: &T, wingspan: u8, home: &str) {\n    println!(\"{}\", animal.fly());\n    println!(\n        \"It uses its wingspan of {} cm to glide back home to the {}!\",\n        wingspan, home\n    );\n}",
    "crumbs": [
      "10. Generic Types, Traits, and Lifetimes"
    ]
  },
  {
    "objectID": "slides/10-generic_types_traits_and_lifetimes.html#custom-traits-and-generics-4",
    "href": "slides/10-generic_types_traits_and_lifetimes.html#custom-traits-and-generics-4",
    "title": "10. Generic Types, Traits, and Lifetimes",
    "section": "Custom traits and generics",
    "text": "Custom traits and generics\nfn fly_home_and_lay_egg&lt;T: Fly + LayEggs&gt;(animal: &T, wingspan: u8, home: &str) {\n    println!(\"{}\", animal.fly());\n    println!(\n        \"It uses its wingspan of {} cm to glide back home to the {}!\",\n        wingspan, home\n    );\n    println!(\"{}\", animal.lay_eggs());\n}",
    "crumbs": [
      "10. Generic Types, Traits, and Lifetimes"
    ]
  },
  {
    "objectID": "slides/10-generic_types_traits_and_lifetimes.html#custom-traits-and-generics-5",
    "href": "slides/10-generic_types_traits_and_lifetimes.html#custom-traits-and-generics-5",
    "title": "10. Generic Types, Traits, and Lifetimes",
    "section": "Custom traits and generics",
    "text": "Custom traits and generics\nfn main() {\n    // Create a bird and a bat\n    let bird = Bird {\n        name: \"Robin\".to_string(),\n        wingspan: 30,\n    };\n\n    let bat = Bat {\n        name: \"Fruit Bat\".to_string(),\n        wingspan: 25,\n    };\n\n    fly_home(&bird, bird.wingspan, \"nest\");\n    fly_home(&bat, bat.wingspan, \"cave\");\n\n    // Uncommenting this line would cause a compilation error\n    // fly_home_and_lay_egg(&bat, bat.wingspan, \"cave\");\n\n    let bird2 = Bird {\n        name: \"Eagle\".to_string(),\n        wingspan: 200,\n    };\n\n    fly_home_and_lay_egg(&bird2, bird2.wingspan, \"mountain nest\");\n}",
    "crumbs": [
      "10. Generic Types, Traits, and Lifetimes"
    ]
  },
  {
    "objectID": "slides/10-generic_types_traits_and_lifetimes.html#lifetimes-1",
    "href": "slides/10-generic_types_traits_and_lifetimes.html#lifetimes-1",
    "title": "10. Generic Types, Traits, and Lifetimes",
    "section": "Lifetimes",
    "text": "Lifetimes\n\nLifetimes are named regions of code that a reference must be valid for. —Rustnomicon",
    "crumbs": [
      "10. Generic Types, Traits, and Lifetimes"
    ]
  },
  {
    "objectID": "slides/10-generic_types_traits_and_lifetimes.html#functions-and-lifetimes",
    "href": "slides/10-generic_types_traits_and_lifetimes.html#functions-and-lifetimes",
    "title": "10. Generic Types, Traits, and Lifetimes",
    "section": "Functions and lifetimes",
    "text": "Functions and lifetimes\nstruct Predator {\n    ecosystem: String,\n}\n\nstruct Prey {\n    ecosystem: String,\n}",
    "crumbs": [
      "10. Generic Types, Traits, and Lifetimes"
    ]
  },
  {
    "objectID": "slides/10-generic_types_traits_and_lifetimes.html#functions-and-lifetimes-1",
    "href": "slides/10-generic_types_traits_and_lifetimes.html#functions-and-lifetimes-1",
    "title": "10. Generic Types, Traits, and Lifetimes",
    "section": "Functions and lifetimes",
    "text": "Functions and lifetimes\nfn describe_hunt&lt;'a&gt;(predator: &'a Predator, prey: &'a Prey) -&gt; &'a str {\n    if predator.ecosystem == prey.ecosystem {\n        \"The hunt begins!\"\n    } else {\n        \"The predator and prey are in different ecosystems, no hunt occurs.\"\n    }\n}",
    "crumbs": [
      "10. Generic Types, Traits, and Lifetimes"
    ]
  },
  {
    "objectID": "slides/10-generic_types_traits_and_lifetimes.html#functions-and-lifetimes-2",
    "href": "slides/10-generic_types_traits_and_lifetimes.html#functions-and-lifetimes-2",
    "title": "10. Generic Types, Traits, and Lifetimes",
    "section": "Functions and lifetimes",
    "text": "Functions and lifetimes\nfn main() {\n    let lion = Predator {\n        ecosystem: String::from(\"savanna\"),\n    };\n\n    let gazelle = Prey {\n        ecosystem: String::from(\"savanna\"),\n    };\n\n    let deer = Prey {\n        ecosystem: String::from(\"forest\"),\n    };\n\n    let result1 = describe_hunt(&lion, &gazelle);\n    let result2 = describe_hunt(&lion, &deer);\n\n    println!(\"Hunting scenario 1: {}\", result1);\n    println!(\"Hunting scenario 2: {}\", result2);\n}",
    "crumbs": [
      "10. Generic Types, Traits, and Lifetimes"
    ]
  },
  {
    "objectID": "slides/10-generic_types_traits_and_lifetimes.html#structs-and-lifetimes",
    "href": "slides/10-generic_types_traits_and_lifetimes.html#structs-and-lifetimes",
    "title": "10. Generic Types, Traits, and Lifetimes",
    "section": "Structs and lifetimes",
    "text": "Structs and lifetimes\nstruct Ecosystem {\n    name: String,\n    biome: String,\n    temperature: f32, // in degrees Celsius\n    description: String,\n}\n\nstruct Animal&lt;'a&gt; {\n    name: String,\n    ecosystem: &'a Ecosystem,\n}",
    "crumbs": [
      "10. Generic Types, Traits, and Lifetimes"
    ]
  },
  {
    "objectID": "slides/10-generic_types_traits_and_lifetimes.html#structs-and-lifetimes-1",
    "href": "slides/10-generic_types_traits_and_lifetimes.html#structs-and-lifetimes-1",
    "title": "10. Generic Types, Traits, and Lifetimes",
    "section": "Structs and lifetimes",
    "text": "Structs and lifetimes\nimpl&lt;'a&gt; Animal&lt;'a&gt; {\n    fn describe(&self) -&gt; String {\n        format!(\n            \"{} lives in the {}, which is a {} biome with an average temperature of {:.1}°C. {}\",\n            self.name,\n            self.ecosystem.name,\n            self.ecosystem.biome,\n            self.ecosystem.temperature,\n            self.ecosystem.description\n        )\n    }\n}",
    "crumbs": [
      "10. Generic Types, Traits, and Lifetimes"
    ]
  },
  {
    "objectID": "slides/10-generic_types_traits_and_lifetimes.html#structs-and-lifetimes-2",
    "href": "slides/10-generic_types_traits_and_lifetimes.html#structs-and-lifetimes-2",
    "title": "10. Generic Types, Traits, and Lifetimes",
    "section": "Structs and lifetimes",
    "text": "Structs and lifetimes\nfn main() {\n    let ecosystem = Ecosystem {\n        name: String::from(\"Amazon Rainforest\"),\n        biome: String::from(\"tropical rainforest\"),\n        temperature: 26.7, \n        description: String::from(\"It is home to a vast array of plant and animal species.\"),\n    };\n\n    let predator = Animal {\n        name: String::from(\"Jaguar\"),\n        ecosystem: &ecosystem,\n    };\n\n    let prey = Animal {\n        name: String::from(\"Capybara\"),\n        ecosystem: &ecosystem,\n    };\n\n    println!(\"{}\", predator.describe());\n    println!(\"{}\", prey.describe());\n}",
    "crumbs": [
      "10. Generic Types, Traits, and Lifetimes"
    ]
  },
  {
    "objectID": "slides/21-appendix.html#slide",
    "href": "slides/21-appendix.html#slide",
    "title": "21. Appendix",
    "section": "SLIDE",
    "text": "SLIDE\n\nDENOTE MAJOR SECTIONS WITH # TITLE (eg # Installation)\nADD INDIVIDUAL SLIDES WITH ## (eg ## rustup on Linux/macOS)\nKEEP THEM RELATIVELY SLIDE-LIKE; THESE ARE NOTES, NOT THE BOOK ITSELF.",
    "crumbs": [
      "21. Appendix"
    ]
  },
  {
    "objectID": "slides/21-appendix.html#slide-1",
    "href": "slides/21-appendix.html#slide-1",
    "title": "21. Appendix",
    "section": "SLIDE",
    "text": "SLIDE",
    "crumbs": [
      "21. Appendix"
    ]
  },
  {
    "objectID": "slides/21-appendix.html#slide-2",
    "href": "slides/21-appendix.html#slide-2",
    "title": "21. Appendix",
    "section": "SLIDE",
    "text": "SLIDE",
    "crumbs": [
      "21. Appendix"
    ]
  },
  {
    "objectID": "slides/21-appendix.html#slide-3",
    "href": "slides/21-appendix.html#slide-3",
    "title": "21. Appendix",
    "section": "SLIDE",
    "text": "SLIDE",
    "crumbs": [
      "21. Appendix"
    ]
  },
  {
    "objectID": "slides/13-functional_language_features_iterators_and_closures.html#functional-programming",
    "href": "slides/13-functional_language_features_iterators_and_closures.html#functional-programming",
    "title": "13. Functional Language Features: Iterators and Closures",
    "section": "Functional Programming",
    "text": "Functional Programming\n\n-\n\nR, at its heart, is a functional language - Hadley Wickham, Advanced R",
    "crumbs": [
      "13. Functional Language Features: Iterators and Closures"
    ]
  },
  {
    "objectID": "slides/13-functional_language_features_iterators_and_closures.html#functional-programming-1",
    "href": "slides/13-functional_language_features_iterators_and_closures.html#functional-programming-1",
    "title": "13. Functional Language Features: Iterators and Closures",
    "section": "Functional Programming",
    "text": "Functional Programming\n\nEmphasizes purity: Focuses on side-effect free, “true” functions.\nAvoid mutability: Promote “assignment free” programming.\nEncourages declarative style: Evaluating expressions over executing statements.\nTreats functions as first-class citizens: Functions are values too.",
    "crumbs": [
      "13. Functional Language Features: Iterators and Closures"
    ]
  },
  {
    "objectID": "slides/13-functional_language_features_iterators_and_closures.html#aside-why-purity-and-immutability-matter",
    "href": "slides/13-functional_language_features_iterators_and_closures.html#aside-why-purity-and-immutability-matter",
    "title": "13. Functional Language Features: Iterators and Closures",
    "section": "Aside: Why purity and immutability matter",
    "text": "Aside: Why purity and immutability matter\n\nEasier to reason about programs.\nLess concern about evaluation order when composing expressions.\nEnables safe concurrency and parallelism.",
    "crumbs": [
      "13. Functional Language Features: Iterators and Closures"
    ]
  },
  {
    "objectID": "slides/13-functional_language_features_iterators_and_closures.html#functional-programming-in-rust",
    "href": "slides/13-functional_language_features_iterators_and_closures.html#functional-programming-in-rust",
    "title": "13. Functional Language Features: Iterators and Closures",
    "section": "Functional programming in Rust",
    "text": "Functional programming in Rust\n\nRust has extensive support for programming in a functional style:\n\nImmutability by Default: Encourage pure functions and minimize side-effects.\nClosures: Functions as values, supporting functional composition.\n\nDeclarative style:\n\nIterators with lazy evaluation for sequence processing\nHigher-Order Functions (e.g., map, filter, fold)\nEnums and pattern matching for sum types.\n\nExpressive Error Handling: Types like Option, Result promote predictable, safe error handling.\n\nThis chapter focuses on the two we have yet to cover: Closures and Iterators.",
    "crumbs": [
      "13. Functional Language Features: Iterators and Closures"
    ]
  },
  {
    "objectID": "slides/13-functional_language_features_iterators_and_closures.html#iterators-and-closures-why-they-matter",
    "href": "slides/13-functional_language_features_iterators_and_closures.html#iterators-and-closures-why-they-matter",
    "title": "13. Functional Language Features: Iterators and Closures",
    "section": "Iterators and Closures: Why they matter",
    "text": "Iterators and Closures: Why they matter\n\nClosures : Function values that capture variables from the environment\nIterators : Abstractions for lazy processing of sequences\nCore to functional programming:\n\nWork together: Closures can used with iterators to enable concise, declarative code. (e.g. map, filter)\nExpress complex operations without explicit state.",
    "crumbs": [
      "13. Functional Language Features: Iterators and Closures"
    ]
  },
  {
    "objectID": "slides/13-functional_language_features_iterators_and_closures.html#closures-in-general",
    "href": "slides/13-functional_language_features_iterators_and_closures.html#closures-in-general",
    "title": "13. Functional Language Features: Iterators and Closures",
    "section": "Closures in general",
    "text": "Closures in general\nExample in R:\nexample_closure &lt;- function(x) {\n    y &lt;- 10\n    function() {\n        x + y\n    }\n}\n\nclosure_instance &lt;- example_closure(5)\nclosure_instance()  # Returns 15\n\nClosures are functions that can capture variables from surrounding environment.\nOne of the key tools for functional programming.\nThese variables are stored alongside the closure for later use.\nIn R, every regular function is a closure, there is no special syntax.",
    "crumbs": [
      "13. Functional Language Features: Iterators and Closures"
    ]
  },
  {
    "objectID": "slides/13-functional_language_features_iterators_and_closures.html#rust-closures",
    "href": "slides/13-functional_language_features_iterators_and_closures.html#rust-closures",
    "title": "13. Functional Language Features: Iterators and Closures",
    "section": "Rust closures",
    "text": "Rust closures\n\nIn Rust, closures can capture their environment as well.\nOrdinary functions are not closures, and do not capture anything.\nOnly anonymous functions can be closures.\nClosure (and function pointers) can be used as first-class citizens:\n\nStored in variables\nPassed as arguments\nReturned from other functions.",
    "crumbs": [
      "13. Functional Language Features: Iterators and Closures"
    ]
  },
  {
    "objectID": "slides/13-functional_language_features_iterators_and_closures.html#closure-syntax",
    "href": "slides/13-functional_language_features_iterators_and_closures.html#closure-syntax",
    "title": "13. Functional Language Features: Iterators and Closures",
    "section": "Closure syntax",
    "text": "Closure syntax\n\nfn   add_one_v1   (num : u32) -&gt; u32 {num + 1}\nlet  add_one_v2 = |num : u32| -&gt; u32 {num + 1};\nlet  add_one_v3 = |num|               num + 1 ;\n\nprintln!(\"{}\",add_one_v3(3)) // 4\n\n\nArguments inclosed in ||instead of ()\nType annotations are optional, rust will generally infer the types.\nCurly brackets also optional for one liner.\nClosure is called just like any other function",
    "crumbs": [
      "13. Functional Language Features: Iterators and Closures"
    ]
  },
  {
    "objectID": "slides/13-functional_language_features_iterators_and_closures.html#inner-function-vs-closure",
    "href": "slides/13-functional_language_features_iterators_and_closures.html#inner-function-vs-closure",
    "title": "13. Functional Language Features: Iterators and Closures",
    "section": "Inner function vs Closure",
    "text": "Inner function vs Closure\n\nfn outer_function() {\n    let outer_variable = 10;\n\n    // Define an inner function\n    fn inner_function() {\n        // Attempt to access outer_variable\n        //println!(\"{}\", outer_variable); // Error: can't capture dynamic environment in a fn item\n    }\n    \n        //  Captures `outer_variable` from the environment\n    let inner_closure = || {\n        println!(\"{}\", outer_variable); \n    };\n\n    inner_function();\n    inner_closure();\n}\n\nfn main(){\n    outer_function();\n}\n\nRust Playground",
    "crumbs": [
      "13. Functional Language Features: Iterators and Closures"
    ]
  },
  {
    "objectID": "slides/13-functional_language_features_iterators_and_closures.html#example-use",
    "href": "slides/13-functional_language_features_iterators_and_closures.html#example-use",
    "title": "13. Functional Language Features: Iterators and Closures",
    "section": "Example use",
    "text": "Example use\n\n#[derive(Debug, PartialEq, Copy, Clone)]\nenum ShirtColor {\n    Red,\n    Blue,\n}\n\nstruct Inventory {\n    shirts: Vec&lt;ShirtColor&gt;,\n}\n\nimpl Inventory {\n    fn giveaway(&self, user_preference: Option&lt;ShirtColor&gt;) -&gt; ShirtColor {\n        user_preference.unwrap_or_else(|| self.most_stocked())\n    }\n\n    fn most_stocked(&self) -&gt; ShirtColor {\n        let mut num_red = 0;\n        let mut num_blue = 0;\n\n        for color in &self.shirts {\n            match color {\n                ShirtColor::Red =&gt; num_red += 1,\n                ShirtColor::Blue =&gt; num_blue += 1,\n            }\n        }\n        if num_red &gt; num_blue {\n            ShirtColor::Red\n        } else {\n            ShirtColor::Blue\n        }\n    }\n}",
    "crumbs": [
      "13. Functional Language Features: Iterators and Closures"
    ]
  },
  {
    "objectID": "slides/13-functional_language_features_iterators_and_closures.html#example-continued",
    "href": "slides/13-functional_language_features_iterators_and_closures.html#example-continued",
    "title": "13. Functional Language Features: Iterators and Closures",
    "section": "Example continued",
    "text": "Example continued\n\nIllustrates use of closure in unwrap_or_else.\nCalls the closure || self.most_stocked() if user_preference is None variant.\nClosure captures self (immutable reference to Inventory)",
    "crumbs": [
      "13. Functional Language Features: Iterators and Closures"
    ]
  },
  {
    "objectID": "slides/13-functional_language_features_iterators_and_closures.html#capturing-modes",
    "href": "slides/13-functional_language_features_iterators_and_closures.html#capturing-modes",
    "title": "13. Functional Language Features: Iterators and Closures",
    "section": "Capturing Modes",
    "text": "Capturing Modes\nClosure can capture values in the same three ways that functions can take parameters\nImmutable Reference\n\nlet list = vec![1, 2, 3];\nlet print_closure = || println!(\"{:?}\", list);\nprint_closure();\n\nMutable reference\n\nlet mut list = vec![1, 2, 3];\nlet mut add_to_list = || list.push(4);\nadd_to_list();\nprintln!(\"{:?}\", list); // [1, 2, 3, 4]",
    "crumbs": [
      "13. Functional Language Features: Iterators and Closures"
    ]
  },
  {
    "objectID": "slides/13-functional_language_features_iterators_and_closures.html#capture-modes-cont",
    "href": "slides/13-functional_language_features_iterators_and_closures.html#capture-modes-cont",
    "title": "13. Functional Language Features: Iterators and Closures",
    "section": "Capture modes (cont)",
    "text": "Capture modes (cont)\nMoving ownership\n\nlet list = vec![1, 2, 3];\nlet moved = || drop(list);\nmoved();\n// println!(\"{:?}\", list); // Error: list has been moved\n\nCan also explicitly move ownership:\n\nlet list = vec![1, 2, 3];\nlet moved = move || println!(\"{:?}\", list);\nmoved();\n// println!(\"{:?}\", list); // Error: list has been moved\n\nRust will use the highest on the list possible: Immutable reference, then mutable if needed, and then move it if needed or requested.",
    "crumbs": [
      "13. Functional Language Features: Iterators and Closures"
    ]
  },
  {
    "objectID": "slides/13-functional_language_features_iterators_and_closures.html#moving-captured-values-out",
    "href": "slides/13-functional_language_features_iterators_and_closures.html#moving-captured-values-out",
    "title": "13. Functional Language Features: Iterators and Closures",
    "section": "Moving captured values out",
    "text": "Moving captured values out\n\nClosure body can do any of the following:\n\nMove a captured value out\nMutate a captured value\nNeither move nor mutate captured values\nCapture nothing\n\nThis determines which traits are implemented\n\nFnOnce : Can be called at least once. All closures implement this.\nFnMut : Can be called multiple times. Implemented by 2-4.\nFn : Can be called multiple times safely. Implemented by 3-4.",
    "crumbs": [
      "13. Functional Language Features: Iterators and Closures"
    ]
  },
  {
    "objectID": "slides/13-functional_language_features_iterators_and_closures.html#fnonce-example",
    "href": "slides/13-functional_language_features_iterators_and_closures.html#fnonce-example",
    "title": "13. Functional Language Features: Iterators and Closures",
    "section": "FnOnce example",
    "text": "FnOnce example\n\nimpl&lt;T&gt; Option&lt;T&gt; {\n    pub fn unwrap_or_else&lt;F&gt;(self, f: F) -&gt; T\n    where\n        F: FnOnce() -&gt; T\n    {\n        match self {\n            Some(x) =&gt; x,\n            None =&gt; f(),\n        }\n    }\n}\n\n\nF is the generic type, with trait bound FnOnce() -&gt; T\nThis means F can be any closure, since we only call it once.",
    "crumbs": [
      "13. Functional Language Features: Iterators and Closures"
    ]
  },
  {
    "objectID": "slides/13-functional_language_features_iterators_and_closures.html#fnmut-example",
    "href": "slides/13-functional_language_features_iterators_and_closures.html#fnmut-example",
    "title": "13. Functional Language Features: Iterators and Closures",
    "section": "FnMut example",
    "text": "FnMut example\n\nimpl&lt;T&gt; [T] {\npub fn sort_by_key&lt;K, F&gt;(&mut self, f: F)\nwhere\n    F: FnMut(&T) -&gt; K,\n    K: Ord,\n// snip\n\n\nStandard library function on slices that takes a function that produces the sort key K.\nOrd is a trait for ordering, requires cmp function, implemented by orderable types (e.g. all numbers)\nTakes a FnMut instead of FnOnce because it must be called multiple times to do the sort.",
    "crumbs": [
      "13. Functional Language Features: Iterators and Closures"
    ]
  },
  {
    "objectID": "slides/13-functional_language_features_iterators_and_closures.html#sort_by_key-usage-example",
    "href": "slides/13-functional_language_features_iterators_and_closures.html#sort_by_key-usage-example",
    "title": "13. Functional Language Features: Iterators and Closures",
    "section": "sort_by_key usage example",
    "text": "sort_by_key usage example\n\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nfn main() {\n    let mut list = [\n        Rectangle { width: 10, height: 1 },\n        Rectangle { width: 3, height: 5 },\n        Rectangle { width: 7, height: 12 },\n    ];\n\n    list.sort_by_key(|r| r.width);\n    println!(\"{list:#?}\");\n}\n\n\nClosure implements all the traits, including FnMut so OK.",
    "crumbs": [
      "13. Functional Language Features: Iterators and Closures"
    ]
  },
  {
    "objectID": "slides/13-functional_language_features_iterators_and_closures.html#broken-example",
    "href": "slides/13-functional_language_features_iterators_and_closures.html#broken-example",
    "title": "13. Functional Language Features: Iterators and Closures",
    "section": "Broken example",
    "text": "Broken example\n\n// snip\nfn main() {\n    let mut list = [\n     // snip\n    ];\n\n    let mut sort_operations = vec![];\n    let value = String::from(\"closure called\");\n\n    list.sort_by_key(|r| {\n        sort_operations.push(value); // Moves capture value out\n        r.width\n    });\n    println!(\"{list:#?}\");\n}\n\n\nClosure moves the captured value value out.\nImplements only FnOnce, not FnMut.\nCompiler error. Rust Playground",
    "crumbs": [
      "13. Functional Language Features: Iterators and Closures"
    ]
  },
  {
    "objectID": "slides/13-functional_language_features_iterators_and_closures.html#fixed-example",
    "href": "slides/13-functional_language_features_iterators_and_closures.html#fixed-example",
    "title": "13. Functional Language Features: Iterators and Closures",
    "section": "Fixed example",
    "text": "Fixed example\n\n\nfn main() {\n    let mut list = [\n      // snip\n    ];\n\n    let mut num_sort_operations = 0;\n    list.sort_by_key(|r| {\n        num_sort_operations += 1;\n        r.width\n    });\n    println!(\"{list:#?}, sorted in {num_sort_operations} operations\");\n}\n\n\nCounts number of calls without moving\nThis time the closure implements FnMut (in addition to FnOnce)",
    "crumbs": [
      "13. Functional Language Features: Iterators and Closures"
    ]
  },
  {
    "objectID": "slides/13-functional_language_features_iterators_and_closures.html#what-are-iterators",
    "href": "slides/13-functional_language_features_iterators_and_closures.html#what-are-iterators",
    "title": "13. Functional Language Features: Iterators and Closures",
    "section": "What are Iterators?",
    "text": "What are Iterators?\n\nDefinition: An Iterator provides a sequence of items (one at a time)\nLaziness: Iterators do nothing until consumed\n\nCalling iter() on a collection by itself does nothing\nMethods like sum(), collect(), or a for loop consume the iterator\n\nBenefit: You avoid writing index-based loops manually\n\nLess chance of off-by-one errors\nConsistent, reusable iteration logic. Functional style.",
    "crumbs": [
      "13. Functional Language Features: Iterators and Closures"
    ]
  },
  {
    "objectID": "slides/13-functional_language_features_iterators_and_closures.html#example",
    "href": "slides/13-functional_language_features_iterators_and_closures.html#example",
    "title": "13. Functional Language Features: Iterators and Closures",
    "section": "Example",
    "text": "Example\nlet v1 = vec![1, 2, 3];\n\n// Creating an iterator (does nothing yet)\nlet v1_iter = v1.iter(); \n\n// Consuming the iterator in a for loop\nfor val in v1_iter {\n    println!(\"Got: {val}\");\n}\n\nN.B. The for syntax will call iter for you, so for val in v1 will also work.",
    "crumbs": [
      "13. Functional Language Features: Iterators and Closures"
    ]
  },
  {
    "objectID": "slides/13-functional_language_features_iterators_and_closures.html#iterator-trait",
    "href": "slides/13-functional_language_features_iterators_and_closures.html#iterator-trait",
    "title": "13. Functional Language Features: Iterators and Closures",
    "section": "Iterator trait",
    "text": "Iterator trait\n\npub trait Iterator {\n    type Item;\n    fn next(&mut self) -&gt; Option&lt;Self::Item&gt;;\n    // other default methods elided\n}\n\n\nOne method required, next.\nItem is an associated type. More on this in Chapter 19.",
    "crumbs": [
      "13. Functional Language Features: Iterators and Closures"
    ]
  },
  {
    "objectID": "slides/13-functional_language_features_iterators_and_closures.html#demonstrating-next",
    "href": "slides/13-functional_language_features_iterators_and_closures.html#demonstrating-next",
    "title": "13. Functional Language Features: Iterators and Closures",
    "section": "Demonstrating next",
    "text": "Demonstrating next\n\n    fn iterator_demonstration() {\n        let v1 = vec![1, 2, 3];\n\n        let mut v1_iter = v1.iter();\n\n        assert_eq!(v1_iter.next(), Some(&1));\n        assert_eq!(v1_iter.next(), Some(&2));\n        assert_eq!(v1_iter.next(), Some(&3));\n        assert_eq!(v1_iter.next(), None);\n    }\n\n\nNote that v1_iter must be mutable. next takes mutable ref to self.\nThis consumes the iterator.\nAlso note that the values are immutable references to the values in v1.\n\niter_mut gives mutable references\ninto_iter gives owned values.",
    "crumbs": [
      "13. Functional Language Features: Iterators and Closures"
    ]
  },
  {
    "objectID": "slides/13-functional_language_features_iterators_and_closures.html#adaptors",
    "href": "slides/13-functional_language_features_iterators_and_closures.html#adaptors",
    "title": "13. Functional Language Features: Iterators and Closures",
    "section": "Adaptors",
    "text": "Adaptors\n\nConsuming Adaptors:\n\nMethods that call next on an iterator.\nExamples: sum and collect\n\nIterator Adaptors:\n\nMethods that transform the iterator into a different one.\nExamples: filter and map.\n\nChain multiple calls to perform complex actions declaratively.",
    "crumbs": [
      "13. Functional Language Features: Iterators and Closures"
    ]
  },
  {
    "objectID": "slides/13-functional_language_features_iterators_and_closures.html#example-1",
    "href": "slides/13-functional_language_features_iterators_and_closures.html#example-1",
    "title": "13. Functional Language Features: Iterators and Closures",
    "section": "Example",
    "text": "Example\n\nfn main(){\n    let v1: Vec&lt;i32&gt; = vec![1, 2, 3, 4, 5, 6];\n    let v2: Vec&lt;_&gt; = v1.iter().filter(|x| *x % 2 == 0).map(|x| x + 1).collect();\n    println!(\"{v2:?}\")  // [3, 5, 7]\n}\n\n\nNote that we need to dereference the x in the filter since iter gives &&i32\nThe type annotation on v2 is not optional, collect can produce different types of collections.",
    "crumbs": [
      "13. Functional Language Features: Iterators and Closures"
    ]
  },
  {
    "objectID": "slides/13-functional_language_features_iterators_and_closures.html#bonus-example",
    "href": "slides/13-functional_language_features_iterators_and_closures.html#bonus-example",
    "title": "13. Functional Language Features: Iterators and Closures",
    "section": "Bonus example",
    "text": "Bonus example\nRust\n\nfn main(){\n    let m = 100;\n    let sum_n = |n| (1..).take(n).fold(0, |sum, i| sum + i); \n    println!(\"Sum first {} integers: {:?}\", m, sum_n(m));\n}\n\nHaskell\nmain :: IO ()\nmain = do\n    let m = 100\n        sumN n = foldl (+) 0 $ take n [1..]\n    putStrLn $ \"Sum first \" ++ show m ++ \" integers: \" ++ show (sumN m)",
    "crumbs": [
      "13. Functional Language Features: Iterators and Closures"
    ]
  },
  {
    "objectID": "slides/13-functional_language_features_iterators_and_closures.html#removing-clone-using-an-iterator.",
    "href": "slides/13-functional_language_features_iterators_and_closures.html#removing-clone-using-an-iterator.",
    "title": "13. Functional Language Features: Iterators and Closures",
    "section": "Removing clone using an iterator.",
    "text": "Removing clone using an iterator.\n\nIO project from last chapter used inefficient clone calls.\nThis was because Config::Build didn’t own args.\nWe can fix this by having Config::Build take ownership of an iterator to the args.",
    "crumbs": [
      "13. Functional Language Features: Iterators and Closures"
    ]
  },
  {
    "objectID": "slides/13-functional_language_features_iterators_and_closures.html#updating-main",
    "href": "slides/13-functional_language_features_iterators_and_closures.html#updating-main",
    "title": "13. Functional Language Features: Iterators and Closures",
    "section": "Updating main",
    "text": "Updating main\n\nfn main() {\n    let config = Config::build(env::args()).unwrap_or_else(|err| {\n        eprintln!(\"Problem parsing arguments: {err}\");\n        process::exit(1);\n    });\n\n    // --snip--\n}\n\n\nenv::args() returns and iterator.\nInstead of collecting , just move it into the build function.\n\nWon’t compile yet, need to fix build",
    "crumbs": [
      "13. Functional Language Features: Iterators and Closures"
    ]
  },
  {
    "objectID": "slides/13-functional_language_features_iterators_and_closures.html#updating-configbuild-signature",
    "href": "slides/13-functional_language_features_iterators_and_closures.html#updating-configbuild-signature",
    "title": "13. Functional Language Features: Iterators and Closures",
    "section": "Updating Config::build signature",
    "text": "Updating Config::build signature\n\nimpl Config {\n    pub fn build(\n        mut args: impl Iterator&lt;Item = String&gt;,\n    ) -&gt; Result&lt;Config, &'static str&gt; {\n        // --snip--\n\n\nAll we need to know about args is that it implements an iterator that returns String items.\nReminder: impl Trait syntax was covered in Chapter 10 and is syntactic sugar for a type variable with a trait bound.",
    "crumbs": [
      "13. Functional Language Features: Iterators and Closures"
    ]
  },
  {
    "objectID": "slides/13-functional_language_features_iterators_and_closures.html#updating-configbuild-body",
    "href": "slides/13-functional_language_features_iterators_and_closures.html#updating-configbuild-body",
    "title": "13. Functional Language Features: Iterators and Closures",
    "section": "Updating Config::build body",
    "text": "Updating Config::build body\n\nimpl Config {\n    pub fn build(\n        mut args: impl Iterator&lt;Item = String&gt;,\n    ) -&gt; Result&lt;Config, &'static str&gt; {\n        args.next();\n\n        let query = match args.next() {\n            Some(arg) =&gt; arg,\n            None =&gt; return Err(\"Didn't get a query string\"),\n        };\n\n        let file_path = match args.next() {\n            Some(arg) =&gt; arg,\n            None =&gt; return Err(\"Didn't get a file path\"),\n        };\n\n        let ignore_case = env::var(\"IGNORE_CASE\").is_ok();\n\n        Ok(Config {\n            query,\n            file_path,\n            ignore_case,\n        })\n    }\n}\n\n\nSince we own the iterator we can move out the owned String values\nNO need to clone!",
    "crumbs": [
      "13. Functional Language Features: Iterators and Closures"
    ]
  },
  {
    "objectID": "slides/13-functional_language_features_iterators_and_closures.html#clean-up-using-iterator-adaptors",
    "href": "slides/13-functional_language_features_iterators_and_closures.html#clean-up-using-iterator-adaptors",
    "title": "13. Functional Language Features: Iterators and Closures",
    "section": "Clean up using Iterator Adaptors",
    "text": "Clean up using Iterator Adaptors\n\npub fn search&lt;'a&gt;(query: &str, contents: &'a str) -&gt; Vec&lt;&'a str&gt; {\n    contents\n        .lines()\n        .filter(|line| line.contains(query))\n        .collect()\n}\n\n\nThis converts the search function to a functional style.\nWe eliminate the mutable state (results in the original code).\nUse of the higher order filter:\n\nRemoves need for mutable state (results)\nRemoves need for looping with contains",
    "crumbs": [
      "13. Functional Language Features: Iterators and Closures"
    ]
  },
  {
    "objectID": "slides/13-functional_language_features_iterators_and_closures.html#example-2",
    "href": "slides/13-functional_language_features_iterators_and_closures.html#example-2",
    "title": "13. Functional Language Features: Iterators and Closures",
    "section": "Example",
    "text": "Example\nLoop\nlet numbers = vec![1, 2, 3, 4, 5];\nlet mut result = Vec::new();\n\nfor &num in &numbers {\n    if num % 2 == 0 {\n        result.push(num * 2);\n    }\n}\n\nprintln!(\"Result: {:?}\", result);\nRust playground\nIterator\nlet numbers = vec![1, 2, 3, 4, 5];\nlet result: Vec&lt;_&gt; = numbers.iter()\n    .filter(|&&x| x % 2 == 0)\n    .map(|&x| x * 2)\n    .collect();\n\nprintln!(\"Result: {:?}\", result);\nRust playground",
    "crumbs": [
      "13. Functional Language Features: Iterators and Closures"
    ]
  },
  {
    "objectID": "slides/13-functional_language_features_iterators_and_closures.html#zero-cost-abstractions",
    "href": "slides/13-functional_language_features_iterators_and_closures.html#zero-cost-abstractions",
    "title": "13. Functional Language Features: Iterators and Closures",
    "section": "Zero-cost abstractions",
    "text": "Zero-cost abstractions\n\n\nIterators often compile to machine code that is as efficient as hand-written loops. This is referred to as a zero-cost abstraction\nThis enables concise, declarative code without sacrificing performance.",
    "crumbs": [
      "13. Functional Language Features: Iterators and Closures"
    ]
  },
  {
    "objectID": "slides/13-functional_language_features_iterators_and_closures.html#summary",
    "href": "slides/13-functional_language_features_iterators_and_closures.html#summary",
    "title": "13. Functional Language Features: Iterators and Closures",
    "section": "Summary",
    "text": "Summary\n\nFunctional programming emphasizes evaluating expressions over executing statements.\nRust provides robust support for functional programming:\n\nClosures for capturing and reusing surrounding context.\n\nIterators for lazy, efficient, and declarative data processing.\n\nHigher-order functions (e.g., map, filter) for transforming data.\n\nImmutability by default\n\nEnables concise, safe code without sacrificing performance.",
    "crumbs": [
      "13. Functional Language Features: Iterators and Closures"
    ]
  },
  {
    "objectID": "slides/15-smart_pointers.html#learning-objectives",
    "href": "slides/15-smart_pointers.html#learning-objectives",
    "title": "15. Smart Pointers",
    "section": "Learning objectives",
    "text": "Learning objectives\n\n\nUnderstand what a smart pointer is\nIdentify common smart pointers\nIdentify use-cases of smart pointers",
    "crumbs": [
      "15. Smart Pointers"
    ]
  },
  {
    "objectID": "slides/15-smart_pointers.html#smart-pointer",
    "href": "slides/15-smart_pointers.html#smart-pointer",
    "title": "15. Smart Pointers",
    "section": "Smart pointer",
    "text": "Smart pointer\n\nSmart pointers … are data structures that act like a pointer but also have additional metadata and capabilities.\n\n\nA pointer (reference) that holds some more information or can do a bit more.",
    "crumbs": [
      "15. Smart Pointers"
    ]
  },
  {
    "objectID": "slides/15-smart_pointers.html#common-smart-pointers",
    "href": "slides/15-smart_pointers.html#common-smart-pointers",
    "title": "15. Smart Pointers",
    "section": "Common smart pointers",
    "text": "Common smart pointers\n\n\nBox&lt;T&gt;\nRc&lt;T&gt;\nRef&lt;T&gt;\n\nRefMut&lt;T&gt;\nRefCell&lt;T&gt;",
    "crumbs": [
      "15. Smart Pointers"
    ]
  },
  {
    "objectID": "slides/15-smart_pointers.html#boxt-1",
    "href": "slides/15-smart_pointers.html#boxt-1",
    "title": "15. Smart Pointers",
    "section": "Box<T>",
    "text": "Box&lt;T&gt;\nPoints to data on the heap\nfn main() {\n    let b = Box::new(5);\n    println!(\"b = {b}\");\n}\n\nReminder: stack is faster to read/write than the heap, but size is needed at compile time",
    "crumbs": [
      "15. Smart Pointers"
    ]
  },
  {
    "objectID": "slides/15-smart_pointers.html#boxt-usage",
    "href": "slides/15-smart_pointers.html#boxt-usage",
    "title": "15. Smart Pointers",
    "section": "Box<T> Usage",
    "text": "Box&lt;T&gt; Usage\n\n\nSize of T unkown & need to use value of T in context where size is needed\nOwn a value & only care that T implements a trait, not specific type of T\nLarge amount of data & need to transfer ownership without copying\n\nTransfering ownership moves data around stack (slow)\nInstead, store data on heap and only keep pointers on stack (fast)\n\n\n\n\nCase 1 - we’ll see shortly\nCase 2 - called trait object, we’ll see in Chapter 17\nCase 3 - if we have a lot of data we want to minimize copying.\nWith Boxes, we can store the large data once, and only need to copy the relatively small data of pointers.",
    "crumbs": [
      "15. Smart Pointers"
    ]
  },
  {
    "objectID": "slides/15-smart_pointers.html#recursive-types-with-boxes",
    "href": "slides/15-smart_pointers.html#recursive-types-with-boxes",
    "title": "15. Smart Pointers",
    "section": "Recursive types with Boxes",
    "text": "Recursive types with Boxes\n(1, (2, (3, Nil)))\ncons list\nEach element contains\n\n\na value\na cons list\n\n\n\nTo see how boxes can be used we’re going to implement what’s called a cons list.",
    "crumbs": [
      "15. Smart Pointers"
    ]
  },
  {
    "objectID": "slides/15-smart_pointers.html#recursive-types-with-boxes-1",
    "href": "slides/15-smart_pointers.html#recursive-types-with-boxes-1",
    "title": "15. Smart Pointers",
    "section": "Recursive types with Boxes",
    "text": "Recursive types with Boxes\nenum List {\n  Cons(i32, List),\n  Nil,\n}\n\nIn Rust speak, a cons list would look something like this.\nNote that this is recursive since the 2nd element of the Cons variant is also a List.",
    "crumbs": [
      "15. Smart Pointers"
    ]
  },
  {
    "objectID": "slides/15-smart_pointers.html#recursive-types-with-boxes-2",
    "href": "slides/15-smart_pointers.html#recursive-types-with-boxes-2",
    "title": "15. Smart Pointers",
    "section": "Recursive types with Boxes",
    "text": "Recursive types with Boxes\n\n\nRust Playground\n\n\nSince this is a recursive data type, the Rust compiler does not know how much memory is needed. It sees this as needing infinite memory.\nLook at error code in Rust Playground:\ncompiler says to use ‘indirection’\n“Indirection” here refers to how a pointer ‘directs’ you to the value.",
    "crumbs": [
      "15. Smart Pointers"
    ]
  },
  {
    "objectID": "slides/15-smart_pointers.html#recursive-types-with-boxes-3",
    "href": "slides/15-smart_pointers.html#recursive-types-with-boxes-3",
    "title": "15. Smart Pointers",
    "section": "Recursive types with Boxes",
    "text": "Recursive types with Boxes\nenum List {\n    Cons(i32, Box&lt;List&gt;),\n    Nil,\n}\n\nRust Playground\n\n\nIf we wrap the List in a Box, we’re telling the compiler that this data structure is not infinite.",
    "crumbs": [
      "15. Smart Pointers"
    ]
  },
  {
    "objectID": "slides/15-smart_pointers.html#recursive-types-with-boxes-4",
    "href": "slides/15-smart_pointers.html#recursive-types-with-boxes-4",
    "title": "15. Smart Pointers",
    "section": "Recursive types with Boxes",
    "text": "Recursive types with Boxes\n\n\nThe compiler knows how much memory a Box requires so it can see that we are no longer in an infinite loop.",
    "crumbs": [
      "15. Smart Pointers"
    ]
  },
  {
    "objectID": "slides/15-smart_pointers.html#deref-trait",
    "href": "slides/15-smart_pointers.html#deref-trait",
    "title": "15. Smart Pointers",
    "section": "Deref trait",
    "text": "Deref trait\nCustomize behavior of dereference * operator\nCode agnostic to pointer type\n\nThe Deref trait allows you to customize how the derefernce operator works for your smart pointer.\nIn doing so it allows you to write code that can work with smart pointers as if they were regular references.",
    "crumbs": [
      "15. Smart Pointers"
    ]
  },
  {
    "objectID": "slides/15-smart_pointers.html#a-pointer-points-to-a-value",
    "href": "slides/15-smart_pointers.html#a-pointer-points-to-a-value",
    "title": "15. Smart Pointers",
    "section": "A pointer ‘points’ to a value",
    "text": "A pointer ‘points’ to a value\nfn main() {\n    let x = 5;\n    let y = &x;\n\n    assert_eq!(5, x);\n    assert_eq!(5, *y);\n}\n\nRust Playground\n\n\nRemember that we use & and * to reference and dereference values.\nHere, y is a reference, or pointer, to x. To access the value of y, we need to dereference it with *.\nRust Playground:\nShow what happens when we remove the *.",
    "crumbs": [
      "15. Smart Pointers"
    ]
  },
  {
    "objectID": "slides/15-smart_pointers.html#boxt-as-a-pointer",
    "href": "slides/15-smart_pointers.html#boxt-as-a-pointer",
    "title": "15. Smart Pointers",
    "section": "Box<T> as a pointer",
    "text": "Box&lt;T&gt; as a pointer\nfn main() {\n    let x = 5;\n    let y = Box::new(x);\n\n    assert_eq!(5, x);\n    assert_eq!(5, *y);\n}\n\nRust Playground\n\n\nSimilarly, we could use a Box in place of a reference, because Box implementes the Deref trait.",
    "crumbs": [
      "15. Smart Pointers"
    ]
  },
  {
    "objectID": "slides/15-smart_pointers.html#ourbox",
    "href": "slides/15-smart_pointers.html#ourbox",
    "title": "15. Smart Pointers",
    "section": "OurBox",
    "text": "OurBox\nstruct OurBox&lt;T&gt;(T);\n\nimpl&lt;T&gt; OurBox&lt;T&gt; {\n    fn new(x: T) -&gt; OurBox&lt;T&gt; {\n        OurBox(x)\n    }\n}\n\nTo see how the Deref trait works, let’s implement our own type of Box.\nWe want it to work with any type T.\nAnd we’ll add a function to create a new box.",
    "crumbs": [
      "15. Smart Pointers"
    ]
  },
  {
    "objectID": "slides/15-smart_pointers.html#ourbox-1",
    "href": "slides/15-smart_pointers.html#ourbox-1",
    "title": "15. Smart Pointers",
    "section": "OurBox",
    "text": "OurBox\nfn main() {\n    let x = 5;\n    let y = OurBox::new(x);\n\n    assert_eq!(5, x);\n    assert_eq!(5, *y);\n}\n\nRust Playground\n\n\nWhat we want is is for our box to function like this, where we can use the dereference operator * to get at the underlying value, just like with references.\nHowever, we can’t quite do that yet because Rust doesn’t know how to derefence our box.\nGo to Rust Playground.",
    "crumbs": [
      "15. Smart Pointers"
    ]
  },
  {
    "objectID": "slides/15-smart_pointers.html#ourbox-2",
    "href": "slides/15-smart_pointers.html#ourbox-2",
    "title": "15. Smart Pointers",
    "section": "OurBox",
    "text": "OurBox\nimpl&lt;T&gt; Deref for OurBox&lt;T&gt; {\n    type Target = T;\n\n    fn deref(&self) -&gt; &Self::Target {\n        &self.0\n    }\n}\n\nRust Playground\n\n\nIn order to use the dereference operator like we would with a regular reference, we need to implement the Deref trait.\nThe deref method takes a reference to self and returns a reference to the data.\nGo to Rust Playground.",
    "crumbs": [
      "15. Smart Pointers"
    ]
  },
  {
    "objectID": "slides/15-smart_pointers.html#deref-coercion",
    "href": "slides/15-smart_pointers.html#deref-coercion",
    "title": "15. Smart Pointers",
    "section": "Deref coercion",
    "text": "Deref coercion\nIf T implements Deref, then &T can be converted to &U.\n\nRust also has functionality called Deref coercion.\nWhat that mean is Rust can automatically convert a reference to a type T to a reference of another type U, as long as T implements Deref.",
    "crumbs": [
      "15. Smart Pointers"
    ]
  },
  {
    "objectID": "slides/15-smart_pointers.html#deref-coercion-1",
    "href": "slides/15-smart_pointers.html#deref-coercion-1",
    "title": "15. Smart Pointers",
    "section": "Deref coercion",
    "text": "Deref coercion\nfn hello(name: &str) {\n    println!(\"Hello, {name}!\");\n}\n\nfn main() {\n    let m = OurBox::new(String::from(\"Rust\"));\n    // hello(&(*m)[..]); w/o Deref coercion\n    hello(&m);\n}\n\nRust Playground\n\n\nAs an example let’s say we have our box point to a String.\nThe String type implements Deref by returning a reference to a str.\nThanks to Deref coercion, we can pass a reference to our box to the function hello even though hello expects a reference to a str.\nWithout Deref coercion, we would have to use a more complicated and hard to read syntax.",
    "crumbs": [
      "15. Smart Pointers"
    ]
  },
  {
    "objectID": "slides/15-smart_pointers.html#drop-trait",
    "href": "slides/15-smart_pointers.html#drop-trait",
    "title": "15. Smart Pointers",
    "section": "Drop trait",
    "text": "Drop trait\nCustomize cleanup behavior when value goes out of scope\n\nSimilar to Deref smart pointers can also have a Drop trait.\nDrop allows you to control what happens when a value of your type goes out of scope.\nLike with Deref, Rust will run this code for you automatically.",
    "crumbs": [
      "15. Smart Pointers"
    ]
  },
  {
    "objectID": "slides/15-smart_pointers.html#drop-trait-1",
    "href": "slides/15-smart_pointers.html#drop-trait-1",
    "title": "15. Smart Pointers",
    "section": "Drop trait",
    "text": "Drop trait\nimpl&lt;T&gt; Drop for OurBox&lt;T&gt; {\n    fn drop(&mut self) {\n        println!(\"Dropping OurBox\");\n    }\n}\n\nfn main() {\n    let _b = OurBox::new(5);\n    println!(\"OurBox '_b' created\");\n}\n\nRust Playground\n\n\nIn this example, our box _b goes out of scope when main does.\nSince we have implented the Drop trait, Rust will automatically call the drop method on OurBox.",
    "crumbs": [
      "15. Smart Pointers"
    ]
  },
  {
    "objectID": "slides/15-smart_pointers.html#stdmemdrop",
    "href": "slides/15-smart_pointers.html#stdmemdrop",
    "title": "15. Smart Pointers",
    "section": "std::mem::drop",
    "text": "std::mem::drop\nstruct OurBox&lt;T&gt;(T);\n\nimpl&lt;T&gt; OurBox&lt;T&gt; {\n    fn new(x: T) -&gt; OurBox&lt;T&gt; {\n        OurBox(x)\n    }\n}\n\nfn main() {\n    let b = OurBox::new(5);\n    println!(\"OurBox 'b' created\");\n    drop(b);\n    println!(\"OurBox 'b' dropped\")\n}\n\nRust Playground\n\n\nRust also provides a mechanism to remove a value manually.\nYou can’t call the method of the Drop trait though, you need to use the drop function in the standard library.\nI don’t really see a use case for this other than manually managing memory, which is out of scope for us, but thought it might be worth mentioning.\nThe whole point of the Drop trait is Rust will call it for you, but it is possible to drop a value manually.",
    "crumbs": [
      "15. Smart Pointers"
    ]
  },
  {
    "objectID": "slides/15-smart_pointers.html#rct-1",
    "href": "slides/15-smart_pointers.html#rct-1",
    "title": "15. Smart Pointers",
    "section": "Rc<T>",
    "text": "Rc&lt;T&gt;\n\nReference counting pointer\n\nmultiple owners\ncount how many references a value has\n\nUse when\n\nneed access to data in multiple places\ndon’t know at compile time who uses data last\n\nUsed in R for modify-in-place vs. copy-on-modify\n\n\nA reference counted pointer is a smart pointer that tracks how many owners a value has.\nWe use an Rc when we need to access data in multiple places, i.e. data has multiple owners.\nBut we don’t know at compile time what part of the program uses the data last.\nIf we did know that, then we could use the normal rules.\nThe last part of the program to use the data would be the owner and we would use the ownership and borrowing rules we are familiar with.\nR actually uses reference counting to determine if a copy needs to be made.\nIf there is only 1 reference to a value it can modify the value in place.\nBut if there is more than 1 reference, it will make a copy.",
    "crumbs": [
      "15. Smart Pointers"
    ]
  },
  {
    "objectID": "slides/15-smart_pointers.html#sharing-data-with-rct",
    "href": "slides/15-smart_pointers.html#sharing-data-with-rct",
    "title": "15. Smart Pointers",
    "section": "Sharing data with Rc<T>",
    "text": "Sharing data with Rc&lt;T&gt;\n\n\nGoing back to cons list that we discussed before, a reference counting smart pointer could be used in a scenario like this.\n‘a’, ‘b’, and ‘c’ are each cons lists.\nBut both ‘b’ and ‘c’ contain list ‘a’.\nIn other words list ‘a’ has multiple owners.",
    "crumbs": [
      "15. Smart Pointers"
    ]
  },
  {
    "objectID": "slides/15-smart_pointers.html#sharing-data-with-rct-1",
    "href": "slides/15-smart_pointers.html#sharing-data-with-rct-1",
    "title": "15. Smart Pointers",
    "section": "Sharing data with Rc<T>",
    "text": "Sharing data with Rc&lt;T&gt;\nenum List {\n    Cons(i32, Box&lt;List&gt;),\n    Nil,\n}\n\nuse crate::List::{Cons, Nil};\n\nfn main() {\n    let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));\n    let b = Cons(3, Box::new(a));\n    let c = Cons(4, Box::new(a));\n}\n\nRust Playground\n\n\nWe could try to implement these lists with Boxes.\nAs we saw before, this will handle the recursive type issue.\nBut it won’t handle the problem of multiple owners because a Box uses the standard ownership rules.\nThe cons lists own their data and we can’t have multiple owners.\nWe could have the cons lists hold references instead.\nBut then we would need to use lifetime parameters where we specify that every item of the list must live as long as the list itself.\nThat won’t work in every scenario though.\nGo to Rust Playground",
    "crumbs": [
      "15. Smart Pointers"
    ]
  },
  {
    "objectID": "slides/15-smart_pointers.html#sharing-data-with-rct-2",
    "href": "slides/15-smart_pointers.html#sharing-data-with-rct-2",
    "title": "15. Smart Pointers",
    "section": "Sharing data with Rc<T>",
    "text": "Sharing data with Rc&lt;T&gt;\nenum List {\n    Cons(i32, Rc&lt;List&gt;),\n    Nil,\n}\n\nuse crate::List::{Cons, Nil};\nuse std::rc::Rc;\n\nfn main() {\n    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));\n    let b = Cons(3, Rc::clone(&a));\n    let c = Cons(4, Rc::clone(&a));\n}\n\nRust Playground\n\n\nWhat we can do though is use an Rc instead of a Box.\nWe create a new reference count pointer a.\nThen pass that to our Cons lists b and c via the Rc::clone method.\nEach time we do this Rc, the count of a is increased.\nSo after c is created for example, Rust knows that a has 3 owners so it knows it can’t remove a.\nIt’s worth noting that Rc::clone does not make a copy of all the data.\nIt only increments the reference count.",
    "crumbs": [
      "15. Smart Pointers"
    ]
  },
  {
    "objectID": "slides/15-smart_pointers.html#tracking-the-count-of-an-rct",
    "href": "slides/15-smart_pointers.html#tracking-the-count-of-an-rct",
    "title": "15. Smart Pointers",
    "section": "Tracking the count of an Rc<T>",
    "text": "Tracking the count of an Rc&lt;T&gt;\nfn main() {\n    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));\n    println!(\"count after creating a = {}\", Rc::strong_count(&a));\n    let b = Cons(3, Rc::clone(&a));\n    println!(\"count after creating b = {}\", Rc::strong_count(&a));\n    {\n        let c = Cons(4, Rc::clone(&a));\n        println!(\"count after creating c = {}\", Rc::strong_count(&a));\n    }\n    println!(\"count after c goes out of scope = {}\", Rc::strong_count(&a));\n}\n\nRust Playground\n\n\nTo see what’s happening under the hood we could add some print statements to print out the current count.\nGo to Rust Playground",
    "crumbs": [
      "15. Smart Pointers"
    ]
  },
  {
    "objectID": "slides/15-smart_pointers.html#refcellt-1",
    "href": "slides/15-smart_pointers.html#refcellt-1",
    "title": "15. Smart Pointers",
    "section": "RefCell<T>",
    "text": "RefCell&lt;T&gt;\n\n“A mutable memory location with dynamically checked borrow rules”\nBorrowing rules enforced at runtime instead of compile time\nUse to implement the interior mutability pattern\n\nmutate data via immutable references\n\n\n\nA RefCell is a smart pointer where borrowing rules are enforced at run time instead of compile time.\nOne use case of this is to have immutable references to mutable data.\nWe can have a structure that is mutable internally, but not externally.\nKind of like a private field in an object.",
    "crumbs": [
      "15. Smart Pointers"
    ]
  },
  {
    "objectID": "slides/15-smart_pointers.html#interior-mutability-with-refcellt---mock-objects",
    "href": "slides/15-smart_pointers.html#interior-mutability-with-refcellt---mock-objects",
    "title": "15. Smart Pointers",
    "section": "Interior mutability with RefCell<T> - mock objects",
    "text": "Interior mutability with RefCell&lt;T&gt; - mock objects\n\nCreate a library to track a value against a maximum value & sends message\nCreate a library to track a value relative to a maximum value\n\nExample: API with limited calls per day\n\nSend message with status of tracked value\n\nUser expected to send message via Messenger trait\n\nUse a mock object for testing\n\n\nTo see how interior mutability works with RefCells we’re going to use an example.\nImagine we have an API where users can call the API a maximum number of times per day.\nWe’ll create a library to track API usage and create a status message.\nThe user will be expected to implement the actual sending of the message but we’ll provide the interface via the Messenger trait.\nFor testing, we’ll create a mock object using RefCells",
    "crumbs": [
      "15. Smart Pointers"
    ]
  },
  {
    "objectID": "slides/15-smart_pointers.html#interior-mutability-with-refcellt---mock-objects-1",
    "href": "slides/15-smart_pointers.html#interior-mutability-with-refcellt---mock-objects-1",
    "title": "15. Smart Pointers",
    "section": "Interior mutability with RefCell<T> - mock objects",
    "text": "Interior mutability with RefCell&lt;T&gt; - mock objects\npub struct LimitTracker&lt;'a, T: Messenger&gt; {\n    messenger: &'a T,\n    value: usize,\n    max: usize,\n}\n\nimpl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;\nwhere\n    T: Messenger,\n{\n    pub fn new(messenger: &'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {\n        LimitTracker {\n            messenger,\n            value: 0,\n            max,\n        }\n    }\n\n    pub fn set_value(&mut self, value: usize) {\n        self.value = value;\n\n        let percentage_of_max = self.value as f64 / self.max as f64;\n\n        if percentage_of_max &gt;= 1.0 {\n            self.messenger.send(\"Error: You are over your quota!\");\n        } else if percentage_of_max &gt;= 0.9 {\n            self.messenger\n                .send(\"Urgent warning: You've used up over 90% of your quota!\");\n        } else if percentage_of_max &gt;= 0.75 {\n            self.messenger\n                .send(\"Warning: You've used up over 75% of your quota!\");\n        }\n    }\n}\n\npub trait Messenger {\n    fn send(&self, msg: &str);\n}\n\nRust Playground\n\n\nWe’ll create a struct called LimitTracker that will contain the API call limit, the current number of API calls, and a messenger.\nWe will need a way to create a new LimitTracker and to set the current number of calls.\nEach time we set this value, we will update the trackers message.\nWe also need a Messenger trait.\nThis has a send method that takes an immutable reference to self.\nUsers will need to implement this trait to send an email for example.\nWe will need to implement this trait for our mock object.",
    "crumbs": [
      "15. Smart Pointers"
    ]
  },
  {
    "objectID": "slides/15-smart_pointers.html#interior-mutability-with-refcellt---mock-objects-2",
    "href": "slides/15-smart_pointers.html#interior-mutability-with-refcellt---mock-objects-2",
    "title": "15. Smart Pointers",
    "section": "Interior mutability with RefCell<T> - mock objects",
    "text": "Interior mutability with RefCell&lt;T&gt; - mock objects\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    struct MockMessenger {\n        sent_messages: Vec&lt;String&gt;,\n    }\n\n    impl MockMessenger {\n        fn new() -&gt; MockMessenger {\n            MockMessenger {\n                sent_messages: vec![],\n            }\n        }\n    }\n\n    impl Messenger for MockMessenger {\n        fn send(&self, message: &str) {\n            self.sent_messages.push(String::from(message));\n        }\n    }\n\n    #[test]\n    fn it_sends_an_over_75_percent_warning_message() {\n        let mock_messenger = MockMessenger::new();\n        let mut limit_tracker = LimitTracker::new(&mock_messenger, 100);\n\n        limit_tracker.set_value(80);\n\n        assert_eq!(mock_messenger.sent_messages.len(), 1);\n    }\n}\n\nRust Playground\n\n\nLike good developers we want to write some tests to ensure our messages are being created correctly.\nWe can do that by creating a MockMessenger struct to keep track of the messages that are sent.\nSince this is a mock for testing, we’re not actually sending anything, we’re just storing the messages in a vector.\nHowever, this doesn’t work.\nThe send method of the Messenger trait expects an immutable reference to self.\nSo we can’t update the sent_messages vector of the mock object because that is a mutable operation.\nWe want to keep our send method to where it takes an immutable reference.",
    "crumbs": [
      "15. Smart Pointers"
    ]
  },
  {
    "objectID": "slides/15-smart_pointers.html#interior-mutability-with-refcellt---mock-objects-3",
    "href": "slides/15-smart_pointers.html#interior-mutability-with-refcellt---mock-objects-3",
    "title": "15. Smart Pointers",
    "section": "Interior mutability with RefCell<T> - mock objects",
    "text": "Interior mutability with RefCell&lt;T&gt; - mock objects\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::cell::RefCell;\n\n    struct MockMessenger {\n        sent_messages: RefCell&lt;Vec&lt;String&gt;&gt;,\n    }\n\n    impl MockMessenger {\n        fn new() -&gt; MockMessenger {\n            MockMessenger {\n                sent_messages: RefCell::new(vec![]),\n            }\n        }\n    }\n\n    impl Messenger for MockMessenger {\n        fn send(&self, message: &str) {\n            self.sent_messages.borrow_mut().push(String::from(message));\n        }\n    }\n\n    #[test]\n    fn it_sends_an_over_75_percent_warning_message() {\n        // --snip--\n\n        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);\n    }\n}\n\nRust Playground\n\n\nTo overcome this we can use a RefCell to wrap our sent_messages vector.\nThen within our send method, we can borrow the sent_messages vector as a mutable and update it’s contents with the message.\nSimilarly, we can borrow the sent_messages vector in the assert statement.\nWe aren’t changing anything here though so we can do an immutable borrow.",
    "crumbs": [
      "15. Smart Pointers"
    ]
  },
  {
    "objectID": "slides/15-smart_pointers.html#combining-refcellt-rct",
    "href": "slides/15-smart_pointers.html#combining-refcellt-rct",
    "title": "15. Smart Pointers",
    "section": "Combining RefCell<T> & Rc<T>",
    "text": "Combining RefCell&lt;T&gt; & Rc&lt;T&gt;\nRefCell&lt;T&gt; + Rc&lt;T&gt; = mutable data with multiple owners\n\nA common pattern is to use both RefCell and reference counting pointers.\nCombining the two allows you to have multiple owners for the same data, along with that data being internally mutable.",
    "crumbs": [
      "15. Smart Pointers"
    ]
  },
  {
    "objectID": "slides/15-smart_pointers.html#combining-refcellt-rct-1",
    "href": "slides/15-smart_pointers.html#combining-refcellt-rct-1",
    "title": "15. Smart Pointers",
    "section": "Combining RefCell<T> & Rc<T>",
    "text": "Combining RefCell&lt;T&gt; & Rc&lt;T&gt;\n\n\n\nRc&lt;T&gt;\n\nmultiple owners of a\nlists are immutable\n\nRc&lt;T&gt; + RefCell&lt;T&gt;\n\nmultiple owners\nmutable lists\n\n\n\n\nGoing back to this cons list example.\nWhen we implemented lists with Rc&lt;T&gt;, it allowed us to have a list with multiple owners.\nHowever, once the lists are created, we can not modify them.\nIf we use RefCell in addtion to Rc though, we can have multiple owners and we can modify the lists after creation.",
    "crumbs": [
      "15. Smart Pointers"
    ]
  },
  {
    "objectID": "slides/15-smart_pointers.html#combining-refcellt-rct-2",
    "href": "slides/15-smart_pointers.html#combining-refcellt-rct-2",
    "title": "15. Smart Pointers",
    "section": "Combining RefCell<T> & Rc<T>",
    "text": "Combining RefCell&lt;T&gt; & Rc&lt;T&gt;\n#[derive(Debug)]\nenum List {\n    Cons(Rc&lt;RefCell&lt;i32&gt;&gt;, Rc&lt;List&gt;),\n    Nil,\n}\n\nuse crate::List::{Cons, Nil};\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\nfn main() {\n    let value = Rc::new(RefCell::new(5));\n\n    let a = Rc::new(Cons(Rc::clone(&value), Rc::new(Nil)));\n\n    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&a));\n    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&a));\n\n    *value.borrow_mut() += 10;\n\n    println!(\"a after = {a:?}\");\n    println!(\"b after = {b:?}\");\n    println!(\"c after = {c:?}\");\n}\n\nRust Playgroud\n\n\nWe can use Rc as before, allowing both b and c to have ownership of a.\nAnd we can place a RefCell within the Rc so that we can modify the value of a after creating it.\nGo to Rust Playground.",
    "crumbs": [
      "15. Smart Pointers"
    ]
  },
  {
    "objectID": "slides/15-smart_pointers.html#refcellt-rct---memory-leaks",
    "href": "slides/15-smart_pointers.html#refcellt-rct---memory-leaks",
    "title": "15. Smart Pointers",
    "section": "RefCell<T> & Rc<T> - memory leaks",
    "text": "RefCell&lt;T&gt; & Rc&lt;T&gt; - memory leaks\n\n\nRust Playground\n\n\nUnfortunately, when using RefCell along with Rc it’s possible to have memory leaks.\nWe could have a situation like this where the cons lists a and b refer to each other in a cycle.\nThis leads to a memory leak because even when a and b go out of scope, their reference counts are never zero.\nThis means that the memory used will never be freed.",
    "crumbs": [
      "15. Smart Pointers"
    ]
  },
  {
    "objectID": "slides/15-smart_pointers.html#prevent-reference-cycles",
    "href": "slides/15-smart_pointers.html#prevent-reference-cycles",
    "title": "15. Smart Pointers",
    "section": "Prevent reference cycles",
    "text": "Prevent reference cycles\n\n\nReplace Rc&lt;T&gt; with Weak&lt;T&gt;\nWeak&lt;T&gt;\n\nweak reference\nno ownership relationship\ncount does not affect Rc&lt;T&gt; clean up\n\n\n\n\nTo get around the cycle issue we can use another smart pointer called a weak reference.\nUnlike Rc&lt;T&gt;, Weak&lt;T&gt; doesn’t have an ownership relationship.\nAnd weak reference counts don’t affect an Rc&lt;T&gt;s strong reference count.",
    "crumbs": [
      "15. Smart Pointers"
    ]
  },
  {
    "objectID": "slides/15-smart_pointers.html#weakt",
    "href": "slides/15-smart_pointers.html#weakt",
    "title": "15. Smart Pointers",
    "section": "Weak<T>",
    "text": "Weak&lt;T&gt;\nuse std::cell::RefCell;\nuse std::rc::{Rc, Weak};\n\n#[derive(Debug)]\nstruct Node {\n    value: i32,\n    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,\n    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,\n}\n\nAs an example, let’s say we need to create a tree data structure.\nWe want any given node to know about both it’s children and it’s parent.\nWe can’t use Rc&lt;T&gt; here because then we would have a reference cycle between a nodes parent and children.\nWe can prevent a cycle by using a Weak reference for the parent and an Rc for the children.\nWith this, a parent node owns it’s child nodes.\nIf we remove a parent node from the tree, it’s children will be removed as well.\nBut by using a Weak reference for the parent of a node, the converse is not true.",
    "crumbs": [
      "15. Smart Pointers"
    ]
  },
  {
    "objectID": "slides/15-smart_pointers.html#weakt-1",
    "href": "slides/15-smart_pointers.html#weakt-1",
    "title": "15. Smart Pointers",
    "section": "Weak<T>",
    "text": "Weak&lt;T&gt;\nfn main() {\n    let leaf = Rc::new(Node {\n        value: 3,\n        parent: RefCell::new(Weak::new()),\n        children: RefCell::new(vec![]),\n    });\n\n    // ...\n}\n\nRust Playground\n\n\nGo to Rust Playground\nAdding print statements let’s us see what is happening internally.",
    "crumbs": [
      "15. Smart Pointers"
    ]
  },
  {
    "objectID": "slides/15-smart_pointers.html#review",
    "href": "slides/15-smart_pointers.html#review",
    "title": "15. Smart Pointers",
    "section": "Review",
    "text": "Review\nWhen to use Box&lt;T&gt;, Rc&lt;T&gt;, and RefCell&lt;T&gt;\n\n\n“Rc enables multiple owners of the same data; Box and RefCell have single owners.”\n“Box allows immutable or mutable borrows checked at compile time; Rc allows only immutable borrows checked at compile time; RefCell allows immutable or mutable borrows checked at runtime.”\n“Because RefCell allows mutable borrows checked at runtime, you can mutate the value inside the RefCell even when the RefCell is immutable.”\n\n\n\nWe’ve talked about a lot of different smart pointers and how to combine them.\nTo finish things off I want to share these guidlines the book provides on when to use the main types of smart pointers we discussed.",
    "crumbs": [
      "15. Smart Pointers"
    ]
  },
  {
    "objectID": "slides/20-final_project_building_a_multithreaded_web_server.html#slide",
    "href": "slides/20-final_project_building_a_multithreaded_web_server.html#slide",
    "title": "20. Final Project: Building a Multithreaded Web Server",
    "section": "SLIDE",
    "text": "SLIDE\n\nDENOTE MAJOR SECTIONS WITH # TITLE (eg # Installation)\nADD INDIVIDUAL SLIDES WITH ## (eg ## rustup on Linux/macOS)\nKEEP THEM RELATIVELY SLIDE-LIKE; THESE ARE NOTES, NOT THE BOOK ITSELF.",
    "crumbs": [
      "20. Final Project: Building a Multithreaded Web Server"
    ]
  },
  {
    "objectID": "slides/20-final_project_building_a_multithreaded_web_server.html#slide-1",
    "href": "slides/20-final_project_building_a_multithreaded_web_server.html#slide-1",
    "title": "20. Final Project: Building a Multithreaded Web Server",
    "section": "SLIDE",
    "text": "SLIDE",
    "crumbs": [
      "20. Final Project: Building a Multithreaded Web Server"
    ]
  },
  {
    "objectID": "slides/20-final_project_building_a_multithreaded_web_server.html#slide-2",
    "href": "slides/20-final_project_building_a_multithreaded_web_server.html#slide-2",
    "title": "20. Final Project: Building a Multithreaded Web Server",
    "section": "SLIDE",
    "text": "SLIDE",
    "crumbs": [
      "20. Final Project: Building a Multithreaded Web Server"
    ]
  },
  {
    "objectID": "slides/20-final_project_building_a_multithreaded_web_server.html#slide-3",
    "href": "slides/20-final_project_building_a_multithreaded_web_server.html#slide-3",
    "title": "20. Final Project: Building a Multithreaded Web Server",
    "section": "SLIDE",
    "text": "SLIDE",
    "crumbs": [
      "20. Final Project: Building a Multithreaded Web Server"
    ]
  },
  {
    "objectID": "slides/03-common_programming_concepts.html#topics-covered",
    "href": "slides/03-common_programming_concepts.html#topics-covered",
    "title": "3. Common Programming Concepts",
    "section": "Topics Covered:",
    "text": "Topics Covered:\n\n\nData Types\n\nScalar\nCompound\n\nVariables, Mutability, Constants, and Shadowing\nFunctions and Control Flow\nError Handling",
    "crumbs": [
      "3. Common Programming Concepts"
    ]
  },
  {
    "objectID": "slides/03-common_programming_concepts.html#integers",
    "href": "slides/03-common_programming_concepts.html#integers",
    "title": "3. Common Programming Concepts",
    "section": "Integers",
    "text": "Integers\n\n\n\n\n\nLength\nSigned\nUnsigned\n\n\n\n\n8-bit\ni8\nu8\n\n\n16-bit\ni16\nu16\n\n\n32-bit\ni32\nu32\n\n\n64-bit\ni64\nu64\n\n\n128-bit\ni128\nu128\n\n\narch\nisize\nusize\n\n\n\n\n\n\nSigned variants can store numbers from -(2n - 1) to 2n - 1 - 1 inclusive\n\ni8: -(27) to 27 - 1, which equals -128 to 127.\nu8: 0- 2n - 1, that is 0 to 28 - 1, which equals 0 to 255",
    "crumbs": [
      "3. Common Programming Concepts"
    ]
  },
  {
    "objectID": "slides/03-common_programming_concepts.html#integer-overflow",
    "href": "slides/03-common_programming_concepts.html#integer-overflow",
    "title": "3. Common Programming Concepts",
    "section": "Integer overflow",
    "text": "Integer overflow\nRust uses two’s complement wrapping to handle integer overflow silently. However, it offers explicit ways to manage overflow:\n\nwrapping_* methods: Always wrap values (e.g., wrapping_add).\nchecked_* methods: Return None if overflow occurs.\noverflowing_* methods: Return the result along with a boolean indicating overflow.\nsaturating_* methods: Clamp the result to the type’s minimum or maximum value.",
    "crumbs": [
      "3. Common Programming Concepts"
    ]
  },
  {
    "objectID": "slides/03-common_programming_concepts.html#floating-point-numbers",
    "href": "slides/03-common_programming_concepts.html#floating-point-numbers",
    "title": "3. Common Programming Concepts",
    "section": "Floating-Point Numbers",
    "text": "Floating-Point Numbers\nTypes: f32 and f64 (primitive types)\n  let pi: f64 = 3.14159;\n\n\nAll floating-point types are signed.\nf32: single-precision float\nf64: double precision float",
    "crumbs": [
      "3. Common Programming Concepts"
    ]
  },
  {
    "objectID": "slides/03-common_programming_concepts.html#booleans-and-characters",
    "href": "slides/03-common_programming_concepts.html#booleans-and-characters",
    "title": "3. Common Programming Concepts",
    "section": "Booleans and Characters",
    "text": "Booleans and Characters\nBoolean: bool\n  let flag = true;\nCharacter: char 1\n  let emoji = '😻';\n\n\nchar type is four bytes in size and represents a Unicode Scalar Value.\nIt can represent more than just ASCII\n\n\n\n\n\nNote that we specify char literals with single quotes, as opposed to string literals, which use double quotes.",
    "crumbs": [
      "3. Common Programming Concepts"
    ]
  },
  {
    "objectID": "slides/03-common_programming_concepts.html#tuples",
    "href": "slides/03-common_programming_concepts.html#tuples",
    "title": "3. Common Programming Concepts",
    "section": "Tuples",
    "text": "Tuples\nGroup values of different types:\n  let tup: (i32, f64, u8) = (500, 6.4, 1);\n  let (x, y, z) = tup; // Destructuring\n\nTuples have a fixed length.",
    "crumbs": [
      "3. Common Programming Concepts"
    ]
  },
  {
    "objectID": "slides/03-common_programming_concepts.html#arrays",
    "href": "slides/03-common_programming_concepts.html#arrays",
    "title": "3. Common Programming Concepts",
    "section": "Arrays",
    "text": "Arrays\nFixed-length collections of the same type:\n  let arr = [1, 2, 3, 4, 5];\n  let first = arr[0];",
    "crumbs": [
      "3. Common Programming Concepts"
    ]
  },
  {
    "objectID": "slides/03-common_programming_concepts.html#initializing-arrays",
    "href": "slides/03-common_programming_concepts.html#initializing-arrays",
    "title": "3. Common Programming Concepts",
    "section": "Initializing arrays",
    "text": "Initializing arrays\n  let a = [3; 5]; // [3, 3, 3, 3, 3]\nShort-hand:\n\n\nvalue of elements; then number of elements\n\n\nlet a = [3; 5];",
    "crumbs": [
      "3. Common Programming Concepts"
    ]
  },
  {
    "objectID": "slides/03-common_programming_concepts.html#accessing-array-elements",
    "href": "slides/03-common_programming_concepts.html#accessing-array-elements",
    "title": "3. Common Programming Concepts",
    "section": "Accessing Array Elements",
    "text": "Accessing Array Elements\nYou can access elements of an array using indexing:\n\n\n0-based indexing (e.g., x[0])\n\n\nfn main() {     \n    let a = [1, 2, 3, 4, 5];      \n    let first = a[0];     \n    let second = a[1]; \n}",
    "crumbs": [
      "3. Common Programming Concepts"
    ]
  },
  {
    "objectID": "slides/03-common_programming_concepts.html#immutable-variables",
    "href": "slides/03-common_programming_concepts.html#immutable-variables",
    "title": "3. Common Programming Concepts",
    "section": "Immutable Variables",
    "text": "Immutable Variables\nVariables in Rust are immutable by default:\n  let x = 5;\n  x = 6; // Error: Cannot assign to immutable variable",
    "crumbs": [
      "3. Common Programming Concepts"
    ]
  },
  {
    "objectID": "slides/03-common_programming_concepts.html#making-variables-mutable",
    "href": "slides/03-common_programming_concepts.html#making-variables-mutable",
    "title": "3. Common Programming Concepts",
    "section": "Making Variables Mutable",
    "text": "Making Variables Mutable\nUse the mut keyword to make variables mutable:\n  let mut y = 10;\n  y += 5; // Now valid because `y` is mutable",
    "crumbs": [
      "3. Common Programming Concepts"
    ]
  },
  {
    "objectID": "slides/03-common_programming_concepts.html#constants",
    "href": "slides/03-common_programming_concepts.html#constants",
    "title": "3. Common Programming Concepts",
    "section": "Constants",
    "text": "Constants\nDeclared with const and are always immutable:\n  const MAX_SCORE: u32 = 100_000;\n\n\nMust always be annotated with a type\nCan be declared in global or function scope\nCannot be computed at runtime",
    "crumbs": [
      "3. Common Programming Concepts"
    ]
  },
  {
    "objectID": "slides/03-common_programming_concepts.html#shadowing",
    "href": "slides/03-common_programming_concepts.html#shadowing",
    "title": "3. Common Programming Concepts",
    "section": "Shadowing",
    "text": "Shadowing\nShadowing allows reusing a variable name:\n  let x = 5;\n  let x = x + 1; // Shadows the previous `x`\n  {\n      let x = x * 2;\n      println!(\"Inner scope x: {x}\");\n  }\n  println!(\"Outer scope x: {x}\");",
    "crumbs": [
      "3. Common Programming Concepts"
    ]
  },
  {
    "objectID": "slides/03-common_programming_concepts.html#differences-between-mut-and-shadowing",
    "href": "slides/03-common_programming_concepts.html#differences-between-mut-and-shadowing",
    "title": "3. Common Programming Concepts",
    "section": "Differences between mut and Shadowing",
    "text": "Differences between mut and Shadowing\n\n\n\n\nmut\nshadowing\n\n\n\n\nType\nSame type\nCan change type (use of let)\n\n\nUse of let\nWhen first declared\nAll instances of variable use",
    "crumbs": [
      "3. Common Programming Concepts"
    ]
  },
  {
    "objectID": "slides/03-common_programming_concepts.html#defining-functions",
    "href": "slides/03-common_programming_concepts.html#defining-functions",
    "title": "3. Common Programming Concepts",
    "section": "Defining Functions",
    "text": "Defining Functions\nfn main() {\n    println!(\"Hello, world!\");\n    another_function();\n}\n\nfn another_function() {\n    println!(\"This is another function.\");\n}",
    "crumbs": [
      "3. Common Programming Concepts"
    ]
  },
  {
    "objectID": "slides/03-common_programming_concepts.html#function-parameters",
    "href": "slides/03-common_programming_concepts.html#function-parameters",
    "title": "3. Common Programming Concepts",
    "section": "Function Parameters",
    "text": "Function Parameters\nFunctions can accept parameters/arguments:\n  fn add(a: i32, b: i32) -&gt; i32 {\n      a + b\n  }\n  println!(\"{}\", add(3, 5));",
    "crumbs": [
      "3. Common Programming Concepts"
    ]
  },
  {
    "objectID": "slides/03-common_programming_concepts.html#return-values",
    "href": "slides/03-common_programming_concepts.html#return-values",
    "title": "3. Common Programming Concepts",
    "section": "Return Values",
    "text": "Return Values\nReturn the last expression from the function body:\n  fn square(x: i32) -&gt; i32 {\n      x * x\n  }",
    "crumbs": [
      "3. Common Programming Concepts"
    ]
  },
  {
    "objectID": "slides/03-common_programming_concepts.html#if-expressions",
    "href": "slides/03-common_programming_concepts.html#if-expressions",
    "title": "3. Common Programming Concepts",
    "section": "if Expressions",
    "text": "if Expressions\nfn main() {\n    let number = 3;\n\n    if number &lt; 5 {\n        println!(\"Condition is true\");\n    } else {\n        println!(\"Condition is false\");\n    }\n}\n\nRust will NOT automatically try to convert non-Boolean types to a Boolean.\nYou must be explicit and always provide if with a Boolean as its condition.",
    "crumbs": [
      "3. Common Programming Concepts"
    ]
  },
  {
    "objectID": "slides/03-common_programming_concepts.html#else-if-for-multiple-conditions",
    "href": "slides/03-common_programming_concepts.html#else-if-for-multiple-conditions",
    "title": "3. Common Programming Concepts",
    "section": "else if for Multiple Conditions",
    "text": "else if for Multiple Conditions\nfn main() {\n    let number = 6;\n\n    if number % 4 == 0 {\n        println!(\"Divisible by 4\");\n    } else if number % 3 == 0 {\n        println!(\"Divisible by 3\");\n    } else {\n        println!(\"Not divisible by 4 or 3\");\n    }\n}\n\nRust only executes the block for the first true condition, and once it finds one, it doesn’t even check the rest.",
    "crumbs": [
      "3. Common Programming Concepts"
    ]
  },
  {
    "objectID": "slides/03-common_programming_concepts.html#using-if-in-a-let-statement",
    "href": "slides/03-common_programming_concepts.html#using-if-in-a-let-statement",
    "title": "3. Common Programming Concepts",
    "section": "Using if in a let Statement",
    "text": "Using if in a let Statement\nif is an expression, hence we can use it on the RHS of a let statement to assign the outcome to a variable\nfn main() {\n    let condition = true;\n    let number = if condition { 5 } else { 6 };\n\n    println!(\"The value of number is: {number}\");\n}\n\n\nnumber variable will be bound to a value based on the outcome of the if expression\nresult values from each arm of the if must be the same type",
    "crumbs": [
      "3. Common Programming Concepts"
    ]
  },
  {
    "objectID": "slides/03-common_programming_concepts.html#for-example",
    "href": "slides/03-common_programming_concepts.html#for-example",
    "title": "3. Common Programming Concepts",
    "section": "For example:",
    "text": "For example:\nfn main() {\n    let condition = true;\n\n    let number = if condition { 5 } else { \"six\" };\n\n    println!(\"The value of number is: {number}\");\n}\nThis throws an error because the types of the values in the if and else blocks are different.",
    "crumbs": [
      "3. Common Programming Concepts"
    ]
  },
  {
    "objectID": "slides/03-common_programming_concepts.html#infinite-loop",
    "href": "slides/03-common_programming_concepts.html#infinite-loop",
    "title": "3. Common Programming Concepts",
    "section": "Infinite loop",
    "text": "Infinite loop\nfn main() {\n    loop {\n        println!(\"Running forever...\");\n    }\n}",
    "crumbs": [
      "3. Common Programming Concepts"
    ]
  },
  {
    "objectID": "slides/03-common_programming_concepts.html#breaking-a-loop",
    "href": "slides/03-common_programming_concepts.html#breaking-a-loop",
    "title": "3. Common Programming Concepts",
    "section": "Breaking a loop",
    "text": "Breaking a loop\nfn main() {\n    let mut counter = 0;\n    let result = loop {\n        counter += 1;\n        if counter == 10 {\n            break counter * 2;\n        }\n    };\n    println!(\"Result: {result}\");\n}\n\nCode after a break or return is never executed.\nThe compiler treats a break expression and a return expression as having the value unit, or ().",
    "crumbs": [
      "3. Common Programming Concepts"
    ]
  },
  {
    "objectID": "slides/03-common_programming_concepts.html#while-loop",
    "href": "slides/03-common_programming_concepts.html#while-loop",
    "title": "3. Common Programming Concepts",
    "section": "while Loop",
    "text": "while Loop\nWhile a condition evaluates to true, the code runs; otherwise, it exits the loop.\nfn main() {\n    let mut number = 3;\n    while number != 0 {\n        println!(\"{number}!\");\n        number -= 1;\n    }\n    println!(\"LIFTOFF!!!\");\n}",
    "crumbs": [
      "3. Common Programming Concepts"
    ]
  },
  {
    "objectID": "slides/03-common_programming_concepts.html#for-loop",
    "href": "slides/03-common_programming_concepts.html#for-loop",
    "title": "3. Common Programming Concepts",
    "section": "for Loop",
    "text": "for Loop\nfor are the most commonly used loop construct in Rust.\nfn main() {\n    let a = [10, 20, 30, 40, 50];\n    for element in a {\n        println!(\"The value is: {element}\");\n    }\n}",
    "crumbs": [
      "3. Common Programming Concepts"
    ]
  },
  {
    "objectID": "slides/03-common_programming_concepts.html#loop-labels-to-disambiguate",
    "href": "slides/03-common_programming_concepts.html#loop-labels-to-disambiguate",
    "title": "3. Common Programming Concepts",
    "section": "loop Labels to Disambiguate",
    "text": "loop Labels to Disambiguate\nLabeling loops when we have loops inside loops 1\nfn main() {\n    let mut count = 0;\n    'counting_up: loop {\n        println!(\"count = {count}\");\n        let mut remaining = 10;\n\n        loop {\n            println!(\"remaining = {remaining}\");\n            if remaining == 9 {\n                break;\n            }\n            if count == 2 {\n                break 'counting_up;\n            }\n            remaining -= 1;\n        }\n\n        count += 1;\n    }\n    println!(\"End count = {count}\");\n}\nThe break 'counting_up; statement will exit the outer loop.\n\n\n\nNotice the single quotes before the label name.",
    "crumbs": [
      "3. Common Programming Concepts"
    ]
  },
  {
    "objectID": "slides/03-common_programming_concepts.html#integer-overflow-1",
    "href": "slides/03-common_programming_concepts.html#integer-overflow-1",
    "title": "3. Common Programming Concepts",
    "section": "Integer Overflow",
    "text": "Integer Overflow\n\nDebug mode: Panics on overflow.\nRelease mode: Uses two’s complement wrapping.\n\nwrapping_* methods: Always wrap values (e.g., wrapping_add).\nchecked_* methods: Return None if overflow occurs.\noverflowing_* methods: Return the result along with a boolean indicating overflow.\nsaturating_* methods: Clamp the result to the type’s minimum or maximum value.",
    "crumbs": [
      "3. Common Programming Concepts"
    ]
  },
  {
    "objectID": "slides/03-common_programming_concepts.html#invalid-array-access",
    "href": "slides/03-common_programming_concepts.html#invalid-array-access",
    "title": "3. Common Programming Concepts",
    "section": "Invalid Array Access",
    "text": "Invalid Array Access\nfn main() {\n    let arr = [1, 2, 3, 4, 5];\n    let index = 10; // Out of bounds\n    let element = arr[index]; // Causes panic\n}",
    "crumbs": [
      "3. Common Programming Concepts"
    ]
  },
  {
    "objectID": "slides/03-common_programming_concepts.html#section",
    "href": "slides/03-common_programming_concepts.html#section",
    "title": "3. Common Programming Concepts",
    "section": "",
    "text": "Feature\nRust\nR\nPython\nC/C++\n\n\n\n\nArrays\nFixed-size, homogeneous types, defined as [T; N].\nHomogeneous data, multidimensional (using array()).\nHomogeneous data, implemented via NumPy (numpy.array).\nFixed-size, homogeneous, defined as T array[N].\n\n\nVectors\nA growable collection with Vec&lt;T&gt;.\n1D array, typically with c() or vector().\nLists mimic vectors, but for true vector operations, use NumPy arrays.\nNo native vector, use std::vector from the Standard Library (C++).\n\n\nTuples\nFixed-length, immutable collection: (i32, f64).\nNot commonly used, lists behave like tuples.\nImmutable, ordered sequence: (1, 2, \"text\").\nUse std::tuple (C++17+) or structures.\n\n\nMatrices\nNot native; use nested Vec&lt;Vec&lt;T&gt;&gt; or external libraries like nalgebra.\n2D structure (matrix()). Can extend to 3D with array().\nImplemented with NumPy as 2D arrays: numpy.matrix or numpy.array.\n2D arrays as T matrix[rows][cols] or use libraries like Eigen in C++.\n\n\nMutability\nVectors (Vec&lt;T&gt;) are mutable; tuples are immutable.\nVectors are mutable; matrices can be altered in-place.\nLists and arrays are mutable; tuples are immutable.\nArrays and vectors (std::vector) are mutable. Tuples are immutable in C++17+.\n\n\nIndexing\n0-based indexing (e.g., x[0]).\n1-based indexing (e.g., x[1]).\n0-based indexing (e.g., x[0]).\n0-based indexing (e.g., x[0]).\n\n\nSize Flexibility\nArrays are fixed, vectors grow dynamically.\nVectors and lists are dynamic. Arrays and matrices have fixed sizes.\nLists and NumPy arrays are dynamic; tuples are fixed size.\nArrays are fixed; std::vector is dynamic.\n\n\n\nA contiguous mutable array type, written as Vec&lt;T&gt;, short for ‘vector’.",
    "crumbs": [
      "3. Common Programming Concepts"
    ]
  },
  {
    "objectID": "slides/14-more_about_cargo_and_cratesio.html#release-profiles",
    "href": "slides/14-more_about_cargo_and_cratesio.html#release-profiles",
    "title": "14. More about Cargo and Crates.io",
    "section": "Release Profiles",
    "text": "Release Profiles\n\nProfiles: Predefined configurations for building code.\n\ndev: For development (cargo build).\nrelease: For production (cargo build --release).\n\n\nConfiguration in Cargo.toml\n[profile.dev]\nopt-level = 0\n\n[profile.release]\nopt-level = 3\n\nopt-level: Optimization levels (0-3).\n\nDevelopment: Minimize build time.\nProduction: Maximize runtime performance.",
    "crumbs": [
      "14. More about Cargo and Crates.io"
    ]
  },
  {
    "objectID": "slides/14-more_about_cargo_and_cratesio.html#steps-to-publish",
    "href": "slides/14-more_about_cargo_and_cratesio.html#steps-to-publish",
    "title": "14. More about Cargo and Crates.io",
    "section": "Steps to Publish",
    "text": "Steps to Publish\n\nCreate an Account: Sign up at crates.io.\nRetrieve API Token: Use cargo login to store it locally.\nAdd Metadata in Cargo.toml:\n\n[package]\nname = \"my_crate\"\ndescription = \"A brief description\"\nlicense = \"MIT OR Apache-2.0\"\n\nRun Publish: cargo publish.",
    "crumbs": [
      "14. More about Cargo and Crates.io"
    ]
  },
  {
    "objectID": "slides/14-more_about_cargo_and_cratesio.html#important-notes",
    "href": "slides/14-more_about_cargo_and_cratesio.html#important-notes",
    "title": "14. More about Cargo and Crates.io",
    "section": "Important Notes",
    "text": "Important Notes\n\nPublished versions are permanent.\nYou can “yank” a version to prevent new dependencies but retain existing ones.",
    "crumbs": [
      "14. More about Cargo and Crates.io"
    ]
  },
  {
    "objectID": "slides/14-more_about_cargo_and_cratesio.html#documentation-comments",
    "href": "slides/14-more_about_cargo_and_cratesio.html#documentation-comments",
    "title": "14. More about Cargo and Crates.io",
    "section": "Documentation Comments",
    "text": "Documentation Comments\n\nUse /// for documentation comments.\nSupports Markdown formatting.",
    "crumbs": [
      "14. More about Cargo and Crates.io"
    ]
  },
  {
    "objectID": "slides/14-more_about_cargo_and_cratesio.html#example",
    "href": "slides/14-more_about_cargo_and_cratesio.html#example",
    "title": "14. More about Cargo and Crates.io",
    "section": "Example",
    "text": "Example\n/// Adds one to the input number.\n///\n/// # Examples\n///\n/// ```\n/// let result = my_crate::add_one(1);\n/// assert_eq!(result, 2);\n/// ```\npub fn add_one(x: i32) -&gt; i32 {\n    x + 1\n}\n\nRun cargo doc --open to generate HTML documentation\nBonus: Examples in comments are tested with cargo test",
    "crumbs": [
      "14. More about Cargo and Crates.io"
    ]
  },
  {
    "objectID": "slides/14-more_about_cargo_and_cratesio.html#what-is-a-workspace",
    "href": "slides/14-more_about_cargo_and_cratesio.html#what-is-a-workspace",
    "title": "14. More about Cargo and Crates.io",
    "section": "What is a Workspace?",
    "text": "What is a Workspace?\n\nA workspace groups multiple crates.\nShared:\n\nCargo.lock (dependency versions).\ntarget directory (build artifacts).",
    "crumbs": [
      "14. More about Cargo and Crates.io"
    ]
  },
  {
    "objectID": "slides/14-more_about_cargo_and_cratesio.html#workspace-configuration",
    "href": "slides/14-more_about_cargo_and_cratesio.html#workspace-configuration",
    "title": "14. More about Cargo and Crates.io",
    "section": "Workspace Configuration",
    "text": "Workspace Configuration\n[workspace]\nmembers = [\"crate1\", \"crate2\"]\nBenefits: - Simplifies management of interdependent crates. - Avoids redundant compilation of dependencies.",
    "crumbs": [
      "14. More about Cargo and Crates.io"
    ]
  },
  {
    "objectID": "slides/14-more_about_cargo_and_cratesio.html#examples-structure",
    "href": "slides/14-more_about_cargo_and_cratesio.html#examples-structure",
    "title": "14. More about Cargo and Crates.io",
    "section": "Examples Structure",
    "text": "Examples Structure\nmy_project/\n├── Cargo.toml (workspace root)\n├── crate1/\n│   ├── Cargo.toml\n│   └── src/\n├── crate2/\n│   ├── Cargo.toml\n│   └── src/\n└── target/",
    "crumbs": [
      "14. More about Cargo and Crates.io"
    ]
  },
  {
    "objectID": "slides/14-more_about_cargo_and_cratesio.html#building-and-testing",
    "href": "slides/14-more_about_cargo_and_cratesio.html#building-and-testing",
    "title": "14. More about Cargo and Crates.io",
    "section": "Building and Testing",
    "text": "Building and Testing\n\nBuild entire workspace: cargo build.\nTest specific crate: cargo test -p crate1.",
    "crumbs": [
      "14. More about Cargo and Crates.io"
    ]
  },
  {
    "objectID": "slides/14-more_about_cargo_and_cratesio.html#installing-binary-crates",
    "href": "slides/14-more_about_cargo_and_cratesio.html#installing-binary-crates",
    "title": "14. More about Cargo and Crates.io",
    "section": "Installing Binary Crates",
    "text": "Installing Binary Crates\n\nUse cargo install:\n\ncargo install ripgrep\n\nBinaries stored in ~/.cargo/bin (add to $PATH).\nRun the tool:\n\nrg --help",
    "crumbs": [
      "14. More about Cargo and Crates.io"
    ]
  },
  {
    "objectID": "slides/14-more_about_cargo_and_cratesio.html#custom-commands",
    "href": "slides/14-more_about_cargo_and_cratesio.html#custom-commands",
    "title": "14. More about Cargo and Crates.io",
    "section": "Custom Commands",
    "text": "Custom Commands\n\nName binaries as cargo-&lt;command&gt;.\nAccessible via cargo &lt;command&gt;.",
    "crumbs": [
      "14. More about Cargo and Crates.io"
    ]
  },
  {
    "objectID": "slides/14-more_about_cargo_and_cratesio.html#example-1",
    "href": "slides/14-more_about_cargo_and_cratesio.html#example-1",
    "title": "14. More about Cargo and Crates.io",
    "section": "Example:",
    "text": "Example:\n\nA binary named cargo-fancy:\n\ncargo fancy\nBenefits: - Extend Cargo without modifying it. - Automatically integrates into cargo --list.",
    "crumbs": [
      "14. More about Cargo and Crates.io"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome",
    "section": "",
    "text": "This is a companion for the book The Rust Programming Language by Steve Klabnik and Carol Nichols, with contributions from the Rust Community (copyright 2024).\nEach chapter title to the left is a link to a slide deck.\n\nThese slides are being developed by this club.\nEach deck will open in its own tab.\nYou may want to type “s” at the start of each deck to open the speaker notes.\nJoin the Data Science Learning Community to participate in the discussion!\n\nWe follow the Data Science Learning Community Code of Conduct.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "slides/16-fearless_concurrency.html#concurrent-vs.-parallel",
    "href": "slides/16-fearless_concurrency.html#concurrent-vs.-parallel",
    "title": "16. Fearless Concurrency",
    "section": "Concurrent vs. Parallel",
    "text": "Concurrent vs. Parallel\n\nConcurrent programming -&gt; different parts of a program execute independently\nParallel programming -&gt; different parts of a program execute at the same time\n“Fearless Concurrency” applies to both concurrent and parallel programming",
    "crumbs": [
      "16. Fearless Concurrency"
    ]
  },
  {
    "objectID": "slides/16-fearless_concurrency.html#fearless-concurrency-with-rust",
    "href": "slides/16-fearless_concurrency.html#fearless-concurrency-with-rust",
    "title": "16. Fearless Concurrency",
    "section": "Fearless Concurrency with Rust",
    "text": "Fearless Concurrency with Rust\n\nRust’s ownership and type system manages memory safety AND concurrency problems\nThis helps convert run-time errors into compile-time errors\nYou can fix your code while you are working on it, rather than after it has been shipped",
    "crumbs": [
      "16. Fearless Concurrency"
    ]
  },
  {
    "objectID": "slides/16-fearless_concurrency.html#opearting-systems-run-programs-concurrently",
    "href": "slides/16-fearless_concurrency.html#opearting-systems-run-programs-concurrently",
    "title": "16. Fearless Concurrency",
    "section": "Opearting systems run programs concurrently",
    "text": "Opearting systems run programs concurrently\n\nOperating systems run executed code in a process\nMultiple processes can be run at once",
    "crumbs": [
      "16. Fearless Concurrency"
    ]
  },
  {
    "objectID": "slides/16-fearless_concurrency.html#programs-can-run-their-parts-concurrently-as-well",
    "href": "slides/16-fearless_concurrency.html#programs-can-run-their-parts-concurrently-as-well",
    "title": "16. Fearless Concurrency",
    "section": "Programs can run their parts concurrently as well",
    "text": "Programs can run their parts concurrently as well\n\nWithin a program, independent parts can also run simultaneously\nThe features that run these independent parts are called threads\ne.g. Web Servers have multiple threads to respond to multiple requests at once",
    "crumbs": [
      "16. Fearless Concurrency"
    ]
  },
  {
    "objectID": "slides/16-fearless_concurrency.html#typical-challenges-of-concurrency",
    "href": "slides/16-fearless_concurrency.html#typical-challenges-of-concurrency",
    "title": "16. Fearless Concurrency",
    "section": "Typical challenges of concurrency",
    "text": "Typical challenges of concurrency\n\nRace conditions: threads accessing resources in an unexpected order\nDeadlocks: where two threads are waiting for each other, preventing progress\nBugs that only happen in certain contexts and are difficult to reproduce",
    "crumbs": [
      "16. Fearless Concurrency"
    ]
  },
  {
    "objectID": "slides/16-fearless_concurrency.html#thread-models",
    "href": "slides/16-fearless_concurrency.html#thread-models",
    "title": "16. Fearless Concurrency",
    "section": "Thread models",
    "text": "Thread models\n\nRust’s standard library uses a 1:1 model of thread implementation\n\nA program uses one operating system thread per one language thread\n\nDifferent crates offer different implementations, with different trade-offs",
    "crumbs": [
      "16. Fearless Concurrency"
    ]
  },
  {
    "objectID": "slides/16-fearless_concurrency.html#spawning-a-thread-in-rust",
    "href": "slides/16-fearless_concurrency.html#spawning-a-thread-in-rust",
    "title": "16. Fearless Concurrency",
    "section": "Spawning a thread in Rust",
    "text": "Spawning a thread in Rust\n\nTo create a new thread, we use thread::spawn, and pass it to a closure\nThe closure should contain the code that we want to run in that thread\nWhen the main thread of a Rust program completes, all spawned threads are shut down\nCode example!",
    "crumbs": [
      "16. Fearless Concurrency"
    ]
  },
  {
    "objectID": "slides/16-fearless_concurrency.html#join-handles",
    "href": "slides/16-fearless_concurrency.html#join-handles",
    "title": "16. Fearless Concurrency",
    "section": "Join handles",
    "text": "Join handles\n\nCalling join on the handle blocks the currently running thread\nIt unblocks when the thread represented by the handle terminates\nCode examples!",
    "crumbs": [
      "16. Fearless Concurrency"
    ]
  },
  {
    "objectID": "slides/16-fearless_concurrency.html#transfer-ownership-with-move",
    "href": "slides/16-fearless_concurrency.html#transfer-ownership-with-move",
    "title": "16. Fearless Concurrency",
    "section": "Transfer ownership with move",
    "text": "Transfer ownership with move\n\nUsing the move keyword with closures passed to thread::spawn\nThis transfer ownership of the values it uses from the environment to the thread\nCode example!",
    "crumbs": [
      "16. Fearless Concurrency"
    ]
  },
  {
    "objectID": "slides/16-fearless_concurrency.html#channels",
    "href": "slides/16-fearless_concurrency.html#channels",
    "title": "16. Fearless Concurrency",
    "section": "Channels",
    "text": "Channels\n\nIn Rust, message passing concurrency is achieved using channels\nChannels can be thought of as the directional channel of a river\nMessages placed in the channel travel downstream until the end",
    "crumbs": [
      "16. Fearless Concurrency"
    ]
  },
  {
    "objectID": "slides/16-fearless_concurrency.html#transmitters-and-receivers",
    "href": "slides/16-fearless_concurrency.html#transmitters-and-receivers",
    "title": "16. Fearless Concurrency",
    "section": "Transmitters and Receivers",
    "text": "Transmitters and Receivers\n\nUpstream: code calls methods on the transmitter with the data you want to send\nDownstream: code checks the receiving end for arriving messages\nA transmitter and receiver can be initialized with mpsc::channel()\nCode example!",
    "crumbs": [
      "16. Fearless Concurrency"
    ]
  },
  {
    "objectID": "slides/16-fearless_concurrency.html#mutexes",
    "href": "slides/16-fearless_concurrency.html#mutexes",
    "title": "16. Fearless Concurrency",
    "section": "Mutexes",
    "text": "Mutexes\n\nShort for Mutual exclusion\nA mutex allows only one owner to access data at any given time\nTo access data in a mutex, a thread must ask to acquire the mutex’s lock\nThe lock keeps track of who currently has exclusive access to the data\n“Mutexes guard the data they hold with a locking system”",
    "crumbs": [
      "16. Fearless Concurrency"
    ]
  },
  {
    "objectID": "slides/16-fearless_concurrency.html#two-rules-of-mutexes",
    "href": "slides/16-fearless_concurrency.html#two-rules-of-mutexes",
    "title": "16. Fearless Concurrency",
    "section": "Two rules of mutexes",
    "text": "Two rules of mutexes\n\nAttempt to acquire their lock before using their data\nWhen you’re done with the data, you must unlock the data\nCode example!",
    "crumbs": [
      "16. Fearless Concurrency"
    ]
  },
  {
    "objectID": "slides/16-fearless_concurrency.html#sharing-a-mutex-between-threads",
    "href": "slides/16-fearless_concurrency.html#sharing-a-mutex-between-threads",
    "title": "16. Fearless Concurrency",
    "section": "Sharing a Mutex between threads",
    "text": "Sharing a Mutex between threads\n\nMutex&lt;T&gt; is not safe to share between multiple threads by default\nUse Arc (Atomic Reference Counting) to enable multiple ownership.\nCode example!",
    "crumbs": [
      "16. Fearless Concurrency"
    ]
  },
  {
    "objectID": "slides/09-error_handling.html#types-of-errors",
    "href": "slides/09-error_handling.html#types-of-errors",
    "title": "9. Error Handling",
    "section": "Types of errors",
    "text": "Types of errors\n\nrecoverable\nunrecoverable\n\n\nRust has 2 types of errors\nRecoverable errors are errors that we would handle through code. For example, maybe we want to retry an operation if it fails the first time.\nUnrecoverable errors crash the program.",
    "crumbs": [
      "9. Error Handling"
    ]
  },
  {
    "objectID": "slides/09-error_handling.html#no-exceptions",
    "href": "slides/09-error_handling.html#no-exceptions",
    "title": "9. Error Handling",
    "section": "No exceptions",
    "text": "No exceptions\n\n\n\nResult&lt;T, E&gt;\npanic!\n\n\n\n\nIt’s worth noting that Rust doesn’t have exceptions. (stop, warn,message in R)\nInstead, it has the Resut&lt;T, E&gt; enum for recoverable errors and the panic! macro for unrecoverable errors.",
    "crumbs": [
      "9. Error Handling"
    ]
  },
  {
    "objectID": "slides/09-error_handling.html#recoverable-errors",
    "href": "slides/09-error_handling.html#recoverable-errors",
    "title": "9. Error Handling",
    "section": "Recoverable errors",
    "text": "Recoverable errors\nenum Result&lt;T, E&gt; {\n    Ok(T),\n    Err(E),\n}\n\n\nT is the type of the returned value on success\nE is the type of the error on failure",
    "crumbs": [
      "9. Error Handling"
    ]
  },
  {
    "objectID": "slides/09-error_handling.html#recoverable-error---reading-a-file",
    "href": "slides/09-error_handling.html#recoverable-error---reading-a-file",
    "title": "9. Error Handling",
    "section": "Recoverable error - reading a file",
    "text": "Recoverable error - reading a file\nuse std::fs::File;\nfn main() {\n    let greeting_file_result = File::open(\"hello.txt\");\n}\n\n\n\nT = std::fs::File\nE = std::io::Error",
    "crumbs": [
      "9. Error Handling"
    ]
  },
  {
    "objectID": "slides/09-error_handling.html#recoverable-error---reading-a-file-1",
    "href": "slides/09-error_handling.html#recoverable-error---reading-a-file-1",
    "title": "9. Error Handling",
    "section": "Recoverable error - reading a file",
    "text": "Recoverable error - reading a file\nuse std::fs::File;\n\nfn main() {\n    let greeting_file_result = File::open(\"hello.txt\");\n\n    let greeting_file = match greeting_file_result {\n        Ok(file) =&gt; file,\n        Err(error) =&gt; panic!(\"Problem opening the file: {error:?}\"),\n    };\n}\n\n\n\nsuccess (Ok) -&gt; std::fs::File\nerror (Err) -&gt; close the program",
    "crumbs": [
      "9. Error Handling"
    ]
  },
  {
    "objectID": "slides/09-error_handling.html#recoverable-error---reading-a-file-2",
    "href": "slides/09-error_handling.html#recoverable-error---reading-a-file-2",
    "title": "9. Error Handling",
    "section": "Recoverable error - reading a file",
    "text": "Recoverable error - reading a file\nuse std::fs::File;\nuse std::io::ErrorKind;\n\nfn main() {\n    let greeting_file_result = File::open(\"hello.txt\");\n\n    let greeting_file = match greeting_file_result {\n        Ok(file) =&gt; file,\n        Err(error) =&gt; match error.kind() {\n            ErrorKind::NotFound =&gt; match File::create(\"hello.txt\") {\n                Ok(fc) =&gt; fc,\n                Err(e) =&gt; panic!(\"Problem creating the file: {e:?}\"),\n            },\n            other_error =&gt; {\n                panic!(\"Problem opening the file: {other_error:?}\");\n            }\n        },\n    };\n}\n\n\n\nsuccess (Ok) -&gt; std::fs::File\nerror (Err) -&gt;\n\nfile not found error (ErrorKind::NotFound) -&gt; create file\n\nsuccess (Ok) -&gt; std::fs::File\nerror -&gt; close the program\n\nother error type -&gt; close the program",
    "crumbs": [
      "9. Error Handling"
    ]
  },
  {
    "objectID": "slides/09-error_handling.html#panic-on-error-shortcuts",
    "href": "slides/09-error_handling.html#panic-on-error-shortcuts",
    "title": "9. Error Handling",
    "section": "panic! on error shortcuts",
    "text": "panic! on error shortcuts\n\n\nunwrap\nuse std::fs::File;\n\nfn main() {\n    let greeting_file = File::open(\"hello.txt\").unwrap();\n}\n\n\nOk -&gt; value\nErr -&gt; panic!\n\n\n\nexpect\nuse std::fs::File;\n\nfn main() {\n    let greeting_file = File::open(\"hello.txt\")\n        .expect(\"hello.txt should be included in this project\");\n}\n\n\nOk -&gt; value\nErr -&gt; panic!\n\npanic!(\"message\")",
    "crumbs": [
      "9. Error Handling"
    ]
  },
  {
    "objectID": "slides/09-error_handling.html#propagating-errors",
    "href": "slides/09-error_handling.html#propagating-errors",
    "title": "9. Error Handling",
    "section": "Propagating errors",
    "text": "Propagating errors\n\n\nreturn error\ncalling code decides what to do\n\n\nuse std::fs::File;\nuse std::io::{self, Read};\n\nfn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {\n    let username_file_result = File::open(\"hello.txt\");\n\n    let mut username_file = match username_file_result {\n        Ok(file) =&gt; file,\n        Err(e) =&gt; return Err(e),\n    };\n\n    let mut username = String::new();\n\n    match username_file.read_to_string(&mut username) {\n        Ok(_) =&gt; Ok(username),\n        Err(e) =&gt; Err(e),\n    }\n}\n\nThe book has quite a bit of text about propogating errors.\nReally what it means is if some operation in your function returns an error, your function returns an error. The code that called your function decides what to do with it.",
    "crumbs": [
      "9. Error Handling"
    ]
  },
  {
    "objectID": "slides/09-error_handling.html#propagating-errors---shortcut",
    "href": "slides/09-error_handling.html#propagating-errors---shortcut",
    "title": "9. Error Handling",
    "section": "Propagating errors - shortcut",
    "text": "Propagating errors - shortcut\n? returns value or returns error (early)\nuse std::fs::File;\nuse std::io::{self, Read};\n\nfn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {\n    let mut username_file = File::open(\"hello.txt\")?;\n\n    let mut username = String::new();\n    username_file.read_to_string(&mut username)?;\n    Ok(username)\n}\n\nThe book provides 2 more examples to make this code even shorter. I didn’t include them here because they are more about the methods of std::fs than about erors. However, you should have a look to see just how short things can get.",
    "crumbs": [
      "9. Error Handling"
    ]
  },
  {
    "objectID": "slides/09-error_handling.html#when-to-use",
    "href": "slides/09-error_handling.html#when-to-use",
    "title": "9. Error Handling",
    "section": "When to use ?",
    "text": "When to use ?\n\n\nCan’t always use it\nReturn type of function must be compatible with type returned by function ? is used on\n\nEx: outer function returns Result, and inner function returns Result\n\n\n\n\nCan’t use ?\nuse std::fs::File;\n\nfn main() {\n    let greeting_file = File::open(\"hello.txt\")?;\n}\n\n\nmain returns ()\nFile::open returns Result",
    "crumbs": [
      "9. Error Handling"
    ]
  },
  {
    "objectID": "slides/05-using_structs_to_structure_related_data.html#topics-covered",
    "href": "slides/05-using_structs_to_structure_related_data.html#topics-covered",
    "title": "5. Using Structs to Structure Related Data",
    "section": "Topics covered",
    "text": "Topics covered\n\n\nStructs\nMethods\nOther associated functions",
    "crumbs": [
      "5. Using Structs to Structure Related Data"
    ]
  },
  {
    "objectID": "slides/05-using_structs_to_structure_related_data.html#defining-structs",
    "href": "slides/05-using_structs_to_structure_related_data.html#defining-structs",
    "title": "5. Using Structs to Structure Related Data",
    "section": "Defining Structs",
    "text": "Defining Structs\nstruct User {\n    active: bool,\n    username: String,\n    email: String,\n    sign_in_count: u64,\n}\n\nStructs are similar to tuples, but with named parts\nSimilar to R named lists, key : value pairs.\nDefines a new type",
    "crumbs": [
      "5. Using Structs to Structure Related Data"
    ]
  },
  {
    "objectID": "slides/05-using_structs_to_structure_related_data.html#instantiating-structs",
    "href": "slides/05-using_structs_to_structure_related_data.html#instantiating-structs",
    "title": "5. Using Structs to Structure Related Data",
    "section": "Instantiating Structs",
    "text": "Instantiating Structs\nfn main() {\n    let mut user1 = User {\n        email: String::from(\"someone@example.com\"),\n        username: String::from(\"someusername123\"),\n        active: true,\n        sign_in_count: 1,\n    };\n    user1.email = String::from(\"anotheremail@example.com\");\n    println!(\"User1's email: {}\",user1.email)\n}\n\nInstantiate (create) by specifying values for each key\nTo get values, use the . notation. compare to R : user1$email\nTo change values, the entire instance must be mutable.",
    "crumbs": [
      "5. Using Structs to Structure Related Data"
    ]
  },
  {
    "objectID": "slides/05-using_structs_to_structure_related_data.html#constructor",
    "href": "slides/05-using_structs_to_structure_related_data.html#constructor",
    "title": "5. Using Structs to Structure Related Data",
    "section": "Constructor",
    "text": "Constructor\nfn build_user(email: String, username: String) -&gt; User {\n    User {\n        active: true,\n        username: username,\n        email: email,\n        sign_in_count: 1,\n    }\n}\n\nStruct is returned as it is the last statement\nWe will see shortly that this will be clearer as an associated function",
    "crumbs": [
      "5. Using Structs to Structure Related Data"
    ]
  },
  {
    "objectID": "slides/05-using_structs_to_structure_related_data.html#shorthand",
    "href": "slides/05-using_structs_to_structure_related_data.html#shorthand",
    "title": "5. Using Structs to Structure Related Data",
    "section": "Shorthand",
    "text": "Shorthand\nfn build_user(email: String, username: String) -&gt; User {\n    User {\n        active: true,\n        username,\n        email,\n        sign_in_count: 1,\n    }\n}\n\nIf variable name is same as field name:\n\nreplace var = var with just var\nfield init shorthand",
    "crumbs": [
      "5. Using Structs to Structure Related Data"
    ]
  },
  {
    "objectID": "slides/05-using_structs_to_structure_related_data.html#struct-update-syntax",
    "href": "slides/05-using_structs_to_structure_related_data.html#struct-update-syntax",
    "title": "5. Using Structs to Structure Related Data",
    "section": "Struct update syntax",
    "text": "Struct update syntax\nfn main() {\n    // --snip--\n\n    let user2 = User {\n        email: String::from(\"another@example.com\"),\n        ..user1\n    };\n}\n\nCreates a new User from an existing instance user1\nNote that this moves data!\n\nWe can no longer use user1 because we moved the username into user2\nIf we had also given a new username then user1 would ok.",
    "crumbs": [
      "5. Using Structs to Structure Related Data"
    ]
  },
  {
    "objectID": "slides/05-using_structs_to_structure_related_data.html#tuple-structs",
    "href": "slides/05-using_structs_to_structure_related_data.html#tuple-structs",
    "title": "5. Using Structs to Structure Related Data",
    "section": "Tuple Structs",
    "text": "Tuple Structs\nstruct Color(i32, i32, i32);\nstruct Point(i32, i32, i32);\n\nfn main() {\n    let black = Color(0, 0, 0);\n    let origin = Point(0, 0, 0);\n}\n\nDefines distinct types for Color and Point\nAccess elements by destructuring\nAlternately can use .0 , .1 etc.",
    "crumbs": [
      "5. Using Structs to Structure Related Data"
    ]
  },
  {
    "objectID": "slides/05-using_structs_to_structure_related_data.html#unit-structs",
    "href": "slides/05-using_structs_to_structure_related_data.html#unit-structs",
    "title": "5. Using Structs to Structure Related Data",
    "section": "Unit Structs",
    "text": "Unit Structs\nstruct AlwaysEqual;\n\nfn main() {\n    let subject = AlwaysEqual;\n}\n\nUseful for cases where you need a type with a singleton value. (Placeholders or markers)\nMore uses will be clearer when we discuss traits.",
    "crumbs": [
      "5. Using Structs to Structure Related Data"
    ]
  },
  {
    "objectID": "slides/05-using_structs_to_structure_related_data.html#references-in-struct",
    "href": "slides/05-using_structs_to_structure_related_data.html#references-in-struct",
    "title": "5. Using Structs to Structure Related Data",
    "section": "References in Struct",
    "text": "References in Struct\nstruct User {\n    active: bool,\n    username: &str,\n    email: &str,\n    sign_in_count: u64,\n}\n\nfn main() {\n    let user1 = User {\n        active: true,\n        username: \"someusername123\",\n        email: \"someone@example.com\",\n        sign_in_count: 1,\n    };\n}\n\nSeems reasonable ?\ntry it out!",
    "crumbs": [
      "5. Using Structs to Structure Related Data"
    ]
  },
  {
    "objectID": "slides/05-using_structs_to_structure_related_data.html#ownership-of-struct-data",
    "href": "slides/05-using_structs_to_structure_related_data.html#ownership-of-struct-data",
    "title": "5. Using Structs to Structure Related Data",
    "section": "Ownership of Struct Data",
    "text": "Ownership of Struct Data\n\nExamples so far used owned data (e.g. String)\nEnsures fields are valid as long as the struct is valid.\nStructs can store references, but this requires explicitly specifying lifetimes to ensure they remain valid (discussed in Chapter 10).",
    "crumbs": [
      "5. Using Structs to Structure Related Data"
    ]
  },
  {
    "objectID": "slides/05-using_structs_to_structure_related_data.html#first-try",
    "href": "slides/05-using_structs_to_structure_related_data.html#first-try",
    "title": "5. Using Structs to Structure Related Data",
    "section": "First try",
    "text": "First try\nfn main() {\n    let width1 = 30;\n    let height1 = 50;\n\n    println!(\n        \"The area of the rectangle is {} square pixels.\",\n        area(width1, height1)\n    );\n}\n\nfn area(width: u32, height: u32) -&gt; u32 {\n    width * height\n}\n\n\nSee seperate repo for example project\nOr use rust playground\n\n\n\nWas it width first or height? (Yeah it doesnt matter here but…)\nWe want area of rectangles, not two numbers",
    "crumbs": [
      "5. Using Structs to Structure Related Data"
    ]
  },
  {
    "objectID": "slides/05-using_structs_to_structure_related_data.html#use-tuples",
    "href": "slides/05-using_structs_to_structure_related_data.html#use-tuples",
    "title": "5. Using Structs to Structure Related Data",
    "section": "Use Tuples",
    "text": "Use Tuples\nfn main() {\n    let rect1 = (30, 50);\n\n    println!(\n        \"The area of the rectangle is {} square pixels.\",\n        area(rect1)\n    );\n}\n\nfn area(dimensions: (u32, u32)) -&gt; u32 {\n    dimensions.0 * dimensions.1\n}\n\nCombined the two into a single object, but …\nWe dont even have argument names to help us now!",
    "crumbs": [
      "5. Using Structs to Structure Related Data"
    ]
  },
  {
    "objectID": "slides/05-using_structs_to_structure_related_data.html#rectangle-struct",
    "href": "slides/05-using_structs_to_structure_related_data.html#rectangle-struct",
    "title": "5. Using Structs to Structure Related Data",
    "section": "Rectangle struct",
    "text": "Rectangle struct\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nfn main() {\n    let rect1 = Rectangle {\n        width: 30,\n        height: 50,\n    };\n\n    println!(\n        \"The area of the rectangle is {} square pixels.\",\n        area(&rect1)\n    );\n}\n\nfn area(rectangle: &Rectangle) -&gt; u32 {\n    rectangle.width * rectangle.height\n}\n\narea function takes a Rectangle - clearer intent\nBit more verbose, but less error prone",
    "crumbs": [
      "5. Using Structs to Structure Related Data"
    ]
  },
  {
    "objectID": "slides/05-using_structs_to_structure_related_data.html#printing-rectangles",
    "href": "slides/05-using_structs_to_structure_related_data.html#printing-rectangles",
    "title": "5. Using Structs to Structure Related Data",
    "section": "Printing Rectangles",
    "text": "Printing Rectangles\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nfn main() {\n    let rect1 = Rectangle {\n        width: 30,\n        height: 50,\n    };\n\n    println!(\"rect1 is {}\", rect1);\n}\n\nTry this in the rust playground\n{} requires implementing std::fmt::Display trait.\n\nBuilt in types implement this, but not user types.\nGet helpful error message! Try {:?} instead!",
    "crumbs": [
      "5. Using Structs to Structure Related Data"
    ]
  },
  {
    "objectID": "slides/05-using_structs_to_structure_related_data.html#debug-printing",
    "href": "slides/05-using_structs_to_structure_related_data.html#debug-printing",
    "title": "5. Using Structs to Structure Related Data",
    "section": "Debug printing",
    "text": "Debug printing\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nfn main() {\n    let rect1 = Rectangle {\n        width: 30,\n        height: 50,\n    };\n\n    println!(\"rect1 is {rect1:?}\");\n}\n\nHmm.. “error[E0277]: Rectangle doesn’t implement Debug”\nBut:\n= help: the trait `Debug` is not implemented for `Rectangle`\n= note: add `#[derive(Debug)]` to `Rectangle` or manually `impl Debug for Rectangle`\nRust can do this automatically but we have to tell it to explicitly.",
    "crumbs": [
      "5. Using Structs to Structure Related Data"
    ]
  },
  {
    "objectID": "slides/05-using_structs_to_structure_related_data.html#try-it",
    "href": "slides/05-using_structs_to_structure_related_data.html#try-it",
    "title": "5. Using Structs to Structure Related Data",
    "section": "Try it?",
    "text": "Try it?\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nfn main() {\n    let rect1 = Rectangle {\n        width: 30,\n        height: 50,\n    };\n\n    println!(\"rect1 is {rect1:?}\");\n}\n\nRust’s helpful error messages can take us far!\nUse {:#?} to ‘pretty print’ the debug info",
    "crumbs": [
      "5. Using Structs to Structure Related Data"
    ]
  },
  {
    "objectID": "slides/05-using_structs_to_structure_related_data.html#dbg-macro",
    "href": "slides/05-using_structs_to_structure_related_data.html#dbg-macro",
    "title": "5. Using Structs to Structure Related Data",
    "section": "dbg! Macro",
    "text": "dbg! Macro\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\nfn main() {\n    let scale = 2;\n    let rect1 = Rectangle {\n        width: dbg!(30 * scale), // dbg! captures this intermediate value\n        height: 50,\n    };\n    dbg!(&rect1);\n}\n\nTakes ownership but then returns the value - print values inside an expression aids in debugging complex expressions.\nPrints file and line number\nPrints to stderr rather then stdout\n\nRust Playground",
    "crumbs": [
      "5. Using Structs to Structure Related Data"
    ]
  },
  {
    "objectID": "slides/05-using_structs_to_structure_related_data.html#more-traits",
    "href": "slides/05-using_structs_to_structure_related_data.html#more-traits",
    "title": "5. Using Structs to Structure Related Data",
    "section": "More traits",
    "text": "More traits\n\nAppendix C has more derivable traits.\nMore on traits in Chapter 10",
    "crumbs": [
      "5. Using Structs to Structure Related Data"
    ]
  },
  {
    "objectID": "slides/05-using_structs_to_structure_related_data.html#defining-methods",
    "href": "slides/05-using_structs_to_structure_related_data.html#defining-methods",
    "title": "5. Using Structs to Structure Related Data",
    "section": "Defining Methods",
    "text": "Defining Methods\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nimpl Rectangle { //implementaiton block\n    fn area(&self) -&gt; u32 {\n        self.width * self.height\n    }\n} // end impl block\n\nfn main() {\n ...\n}\nRust Playground\n\nMethods are like functions but defined within the context of a struct, enum, or trait object using an impl block\nFirst parameter is always self.",
    "crumbs": [
      "5. Using Structs to Structure Related Data"
    ]
  },
  {
    "objectID": "slides/05-using_structs_to_structure_related_data.html#method-calls",
    "href": "slides/05-using_structs_to_structure_related_data.html#method-calls",
    "title": "5. Using Structs to Structure Related Data",
    "section": "Method calls",
    "text": "Method calls\nfn main() {\n    let rect1 = Rectangle {\n        width: 30,\n        height: 50,\n    };\n\n    println!(\n        \"The area of the rectangle is {} square pixels.\",\n        rect1.area()\n    );\n}\n\nUses the . syntax, automatically passes in self\nNo need for -&gt; as in c++, Rust automatically dereferences as required to make this more ergonomic!\np1.distance(&p2);\n(&p1).distance(&p2); \\\\same but more verbose",
    "crumbs": [
      "5. Using Structs to Structure Related Data"
    ]
  },
  {
    "objectID": "slides/05-using_structs_to_structure_related_data.html#self",
    "href": "slides/05-using_structs_to_structure_related_data.html#self",
    "title": "5. Using Structs to Structure Related Data",
    "section": "Self",
    "text": "Self\n\n&self is shorthand for self : &Self\nSelf is shorthand for the object type. (Rectangle)\n&self or &mut self, borrowing, is most common\nusing just self and taking ownership is rare.",
    "crumbs": [
      "5. Using Structs to Structure Related Data"
    ]
  },
  {
    "objectID": "slides/05-using_structs_to_structure_related_data.html#associated-functions",
    "href": "slides/05-using_structs_to_structure_related_data.html#associated-functions",
    "title": "5. Using Structs to Structure Related Data",
    "section": "Associated Functions",
    "text": "Associated Functions\nimpl Rectangle {\n    fn square(size: u32) -&gt; Self {\n        Self {\n            width: size,\n            height: size,\n        }\n    }\n}\n\nAssociated functions are defined in an impl block without self\nimpl organizes code related to the type in one place\nThese functions can refer to the Self type, and commonly do in ‘constructor’ functions as above.\nAssociated functions are called like this: Rectangle::square(3). This should be familiar! String::new().",
    "crumbs": [
      "5. Using Structs to Structure Related Data"
    ]
  },
  {
    "objectID": "slides/05-using_structs_to_structure_related_data.html#other-notes",
    "href": "slides/05-using_structs_to_structure_related_data.html#other-notes",
    "title": "5. Using Structs to Structure Related Data",
    "section": "Other notes",
    "text": "Other notes\nimpl Rectangle {\n    fn area(&self) -&gt; u32 {\n        self.width * self.height\n    }\n}\n\nimpl Rectangle {\n    fn can_hold(&self, other: &Rectangle) -&gt; bool {\n        self.width &gt; other.width && self.height &gt; other.height\n    }\n}\n\nMethods can have more arguments then just self\nThere can be multiple impl blocks. Not needed here but this is useful for generics and traits in Chapter 10.",
    "crumbs": [
      "5. Using Structs to Structure Related Data"
    ]
  },
  {
    "objectID": "slides/00-club-intro.html#book-club-meetings",
    "href": "slides/00-club-intro.html#book-club-meetings",
    "title": "Club Meetings",
    "section": "Book club meetings",
    "text": "Book club meetings\n\nVolunteer leads discussion of a chapter\n\nThis is the best way to learn the material.\n\nPresentations:\n\nReview of material\nQuestions you have\nMaybe live demo\n\nMore info about editing: this github repo.\nRecorded, available on the Data Science Learning Community YouTube Channel (DSLC.video).\nSign up to present\n\n\nIn case this is your first book club here, this is how things work. We’ll meet weekly and have a presentation followed by a discussion.\nWe’re working through this book collaboratively so everyone is encouraged to present a session or two. Please have a look at the schedule ASAP. We need presenters for the next 2 weeks.",
    "crumbs": [
      "Club Meetings"
    ]
  },
  {
    "objectID": "slides/00-club-intro.html#pace",
    "href": "slides/00-club-intro.html#pace",
    "title": "Club Meetings",
    "section": "Pace",
    "text": "Pace\n\nGoal: 1 chapter/week\nOk to split overwhelming chapters\nOk to combine short chapters\nMeet every week except holidays, etc\n\nIdeally can discuss even if presenter unavailable\n\nMonday at 2:00 pm PST (2100 GMT)\n\n\nThe schedule will be consistent for the most part but if we need to make adjustments everyone will be notified well ahead of time. For example, we will most likely meet for one of the scheduled holiday breaks or combine 2 chapters to one week. Daylight savings in the spring comes right at the end of schedule and is particularly gnarly this year I’d like to finish before then.",
    "crumbs": [
      "Club Meetings"
    ]
  },
  {
    "objectID": "slides/00-club-intro.html#learning-objectives-los",
    "href": "slides/00-club-intro.html#learning-objectives-los",
    "title": "Club Meetings",
    "section": "Learning objectives (LOs)",
    "text": "Learning objectives (LOs)\n\nStudents who study with LOs in mind retain more.\nTips:\n\n“After today’s session, you will be able to…”\nVery roughly 1 per section.\n\n\n\nWhen writing your presentation it can help to define learning objectives. This can help you identify the key points of the chapter, which also helps everyone else. It’s not strictly required though so don’t stress about it.",
    "crumbs": [
      "Club Meetings"
    ]
  },
  {
    "objectID": "slides/11-writing_automated_tests.html#testing-in-rust",
    "href": "slides/11-writing_automated_tests.html#testing-in-rust",
    "title": "11. Writing Automated Tests",
    "section": "Testing in Rust",
    "text": "Testing in Rust\n\nTests ensure code functions as expected\nRust (cargo) provides native support for automating tests\nTypes of test in Rust include:\n\n\nUnit tests\nIntegration tests\nDocumentation tests\nBenchmarks\n\n\n\n\nIn this chapter, we’ll explore how to write tests in Rust to ensure our code works correctly. We’ll learn about unit tests, which test small pieces of code in isolation, and integration tests, which test how different parts of your code work together.",
    "crumbs": [
      "11. Writing Automated Tests"
    ]
  },
  {
    "objectID": "slides/11-writing_automated_tests.html#typical-flow-of-a-test",
    "href": "slides/11-writing_automated_tests.html#typical-flow-of-a-test",
    "title": "11. Writing Automated Tests",
    "section": "Typical Flow of a Test",
    "text": "Typical Flow of a Test\n\nSet up any needed data or state.\nRun the code you want to test.\nAssert that the results are what you expect.",
    "crumbs": [
      "11. Writing Automated Tests"
    ]
  },
  {
    "objectID": "slides/11-writing_automated_tests.html#anatomy-of-a-test-function",
    "href": "slides/11-writing_automated_tests.html#anatomy-of-a-test-function",
    "title": "11. Writing Automated Tests",
    "section": "Anatomy of a Test Function",
    "text": "Anatomy of a Test Function\n\nAnnotate functions with #[test] to make them tests\n#[test]\nfn it_works() {\n    assert_eq!(2 + 2, 4);\n}\nRun tests with cargo test\n\n\nTest functions are regular functions annotated with #[test]. When you run cargo test, Rust looks for functions annotated with #[test] and runs them.",
    "crumbs": [
      "11. Writing Automated Tests"
    ]
  },
  {
    "objectID": "slides/11-writing_automated_tests.html#the-assert-macro",
    "href": "slides/11-writing_automated_tests.html#the-assert-macro",
    "title": "11. Writing Automated Tests",
    "section": "The assert! Macro",
    "text": "The assert! Macro\n\nEnsures a condition evaluates to true\nassert!(condition);\nExample:\n#[test]\nfn larger_can_hold_smaller() {\n    let larger = Rectangle { width: 8, height: 7 };\n    let smaller = Rectangle { width: 5, height: 1 };\n\n    assert!(larger.can_hold(&smaller));\n}\n\n\nThe assert! macro is used to check that a condition is true. If it isn’t, the test fails.",
    "crumbs": [
      "11. Writing Automated Tests"
    ]
  },
  {
    "objectID": "slides/11-writing_automated_tests.html#the-assert_eq-and-assert_ne-macros",
    "href": "slides/11-writing_automated_tests.html#the-assert_eq-and-assert_ne-macros",
    "title": "11. Writing Automated Tests",
    "section": "The assert_eq! and assert_ne! Macros",
    "text": "The assert_eq! and assert_ne! Macros\n\nassert_eq!(left, right) checks left == right\nassert_ne!(left, right) checks left != right\nProvide detailed error messages on failure\nExample:\n#[test]\nfn it_adds_two() {\n    assert_eq!(add_two(2), 4);\n}\n\n\nThese macros are useful for comparing values in tests. They display the values when the test fails, which helps with debugging.",
    "crumbs": [
      "11. Writing Automated Tests"
    ]
  },
  {
    "objectID": "slides/11-writing_automated_tests.html#adding-custom-failure-messages",
    "href": "slides/11-writing_automated_tests.html#adding-custom-failure-messages",
    "title": "11. Writing Automated Tests",
    "section": "Adding Custom Failure Messages",
    "text": "Adding Custom Failure Messages\n\nAdd custom messages to assertions\nassert!(condition, \"Custom message\");\nExample:\n#[test]\nfn greeting_contains_name() {\n    let result = greeting(\"Carol\");\n    assert!(\n        result.contains(\"Carol\"),\n        \"Greeting did not contain name, value was `{}`\",\n        result\n    );\n}\n\n\nCustom messages can help explain why a test failed, making it easier to diagnose issues.",
    "crumbs": [
      "11. Writing Automated Tests"
    ]
  },
  {
    "objectID": "slides/11-writing_automated_tests.html#checking-for-panics-with-should_panic",
    "href": "slides/11-writing_automated_tests.html#checking-for-panics-with-should_panic",
    "title": "11. Writing Automated Tests",
    "section": "Checking for Panics with should_panic",
    "text": "Checking for Panics with should_panic\n\nUse #[should_panic] to test code that should panic\n#[test]\n#[should_panic]\nfn test_panics() {\n    // code that should panic\n}\nUse expected to specify a substring of the panic message\n#[test]\n#[should_panic(expected = \"must be less than or equal to 100\")]\nfn greater_than_100() {\n    Guess::new(200);\n}\n\n\nThis attribute tells Rust that the test should pass if the code inside panics. The expected parameter allows you to check that the panic message contains specific text.",
    "crumbs": [
      "11. Writing Automated Tests"
    ]
  },
  {
    "objectID": "slides/11-writing_automated_tests.html#using-resultt-e-in-tests",
    "href": "slides/11-writing_automated_tests.html#using-resultt-e-in-tests",
    "title": "11. Writing Automated Tests",
    "section": "Using Result<T, E> in Tests",
    "text": "Using Result&lt;T, E&gt; in Tests\n\nTests can return Result&lt;T, E&gt; instead of panicking\n#[test]\nfn it_works() -&gt; Result&lt;(), String&gt; {\n    // code that might return Err\n    Ok(())\n}\nAllows use of the ? operator in tests\n\n\nReturning Result in tests can be convenient when using functions that return Result, allowing the use of the ? operator.",
    "crumbs": [
      "11. Writing Automated Tests"
    ]
  },
  {
    "objectID": "slides/11-writing_automated_tests.html#running-tests-in-parallel-or-consecutively",
    "href": "slides/11-writing_automated_tests.html#running-tests-in-parallel-or-consecutively",
    "title": "11. Writing Automated Tests",
    "section": "Running Tests in Parallel or Consecutively",
    "text": "Running Tests in Parallel or Consecutively\n\nTests run in parallel by default\nTo run tests consecutively:\ncargo test -- --test-threads=1\n\n\nRunning tests in parallel speeds up test execution, but sometimes you may need to run tests one at a time, for example, if they interact with shared state.",
    "crumbs": [
      "11. Writing Automated Tests"
    ]
  },
  {
    "objectID": "slides/11-writing_automated_tests.html#showing-function-output",
    "href": "slides/11-writing_automated_tests.html#showing-function-output",
    "title": "11. Writing Automated Tests",
    "section": "Showing Function Output",
    "text": "Showing Function Output\n\nOutput from println! is captured by default\nTo display output even for passing tests:\ncargo test -- --show-output\n\n\nBy default, Rust captures output from tests to keep the test output clean. Use --show-output to see the output from println! and other macros.",
    "crumbs": [
      "11. Writing Automated Tests"
    ]
  },
  {
    "objectID": "slides/11-writing_automated_tests.html#running-a-subset-of-tests-by-name",
    "href": "slides/11-writing_automated_tests.html#running-a-subset-of-tests-by-name",
    "title": "11. Writing Automated Tests",
    "section": "Running a Subset of Tests by Name",
    "text": "Running a Subset of Tests by Name\nRunning Single Tests\n\nRun a specific test by specifying its name:\ncargo test test_name\n\nFiltering Multiple Tests\n\nRun tests matching a pattern:\ncargo test pattern\n\n\nThis is useful when you have many tests and want to focus on a subset.",
    "crumbs": [
      "11. Writing Automated Tests"
    ]
  },
  {
    "objectID": "slides/11-writing_automated_tests.html#ignoring-some-tests-unless-specifically-requested",
    "href": "slides/11-writing_automated_tests.html#ignoring-some-tests-unless-specifically-requested",
    "title": "11. Writing Automated Tests",
    "section": "Ignoring Some Tests Unless Specifically Requested",
    "text": "Ignoring Some Tests Unless Specifically Requested\n\nUse #[ignore] to exclude tests by default\n#[test]\n#[ignore]\nfn expensive_test() {\n    // code that takes a long time\n}\nRun ignored tests with:\ncargo test -- --ignored\n\n\nIgnored tests can be useful for tests that take a long time or require special setup.",
    "crumbs": [
      "11. Writing Automated Tests"
    ]
  },
  {
    "objectID": "slides/11-writing_automated_tests.html#unit-tests",
    "href": "slides/11-writing_automated_tests.html#unit-tests",
    "title": "11. Writing Automated Tests",
    "section": "Unit Tests",
    "text": "Unit Tests\n\nTest individual units of code in isolation\nPlaced in the same file as the code under test\n\nThe Tests Module and #[cfg(test)]\n\nPlace tests in a tests module annotated with #[cfg(test)]\nThis module is only compiled when testing\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn it_works() {\n        // test code\n    }\n}\n\n\nThe #[cfg(test)] attribute ensures the tests are only compiled and run when testing.",
    "crumbs": [
      "11. Writing Automated Tests"
    ]
  },
  {
    "objectID": "slides/11-writing_automated_tests.html#testing-private-functions",
    "href": "slides/11-writing_automated_tests.html#testing-private-functions",
    "title": "11. Writing Automated Tests",
    "section": "Testing Private Functions",
    "text": "Testing Private Functions\n\nYou can test private functions in Rust\nExample:\nfn internal_adder(a: i32, b: i32) -&gt; i32 {\n    a + b\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_internal() {\n        assert_eq!(internal_adder(2, 2), 4);\n    }\n}\n\n\nBecause the tests module is inside the same file, it has access to private functions.",
    "crumbs": [
      "11. Writing Automated Tests"
    ]
  },
  {
    "objectID": "slides/11-writing_automated_tests.html#integration-tests",
    "href": "slides/11-writing_automated_tests.html#integration-tests",
    "title": "11. Writing Automated Tests",
    "section": "Integration Tests",
    "text": "Integration Tests\n\nTest the public API as an external user would\nPlaced in the tests directory\nEach file in tests is a separate crate\nmy_project\n├── Cargo.toml\n├── src\n│   └── lib.rs\n└── tests\n    └── integration_test.rs\nExample:\nuse my_project;\n\n#[test]\nfn it_adds_two() {\n    assert_eq!(my_project::add_two(2), 4);\n}\n\n\nIntegration tests verify that your library works as expected when used by others.",
    "crumbs": [
      "11. Writing Automated Tests"
    ]
  },
  {
    "objectID": "slides/11-writing_automated_tests.html#submodules-in-integration-tests",
    "href": "slides/11-writing_automated_tests.html#submodules-in-integration-tests",
    "title": "11. Writing Automated Tests",
    "section": "Submodules in Integration Tests",
    "text": "Submodules in Integration Tests\n\nShare code between integration tests using modules\nCreate tests/common/mod.rs for shared code\n// tests/common/mod.rs\npub fn setup() {\n    // setup code\n}\n\n// tests/integration_test.rs\nmod common;\n\n#[test]\nfn it_adds_two() {\n    common::setup();\n    assert_eq!(my_project::add_two(2), 4);\n}\n\n\nThis avoids code duplication in your tests.",
    "crumbs": [
      "11. Writing Automated Tests"
    ]
  },
  {
    "objectID": "slides/11-writing_automated_tests.html#integration-tests-for-binary-crates",
    "href": "slides/11-writing_automated_tests.html#integration-tests-for-binary-crates",
    "title": "11. Writing Automated Tests",
    "section": "Integration Tests for Binary Crates",
    "text": "Integration Tests for Binary Crates\n\nBinary crates (with only main.rs) can’t be tested directly via integration tests\nSolution: Extract logic into a library crate (lib.rs)\nmain.rs can then call into lib.rs\n\n\nThis allows you to test your core functionality separately from your binary interface.",
    "crumbs": [
      "11. Writing Automated Tests"
    ]
  },
  {
    "objectID": "slides/08-common_collections.html#what-is-a-collection",
    "href": "slides/08-common_collections.html#what-is-a-collection",
    "title": "8. Common Collections",
    "section": "What is a ‘collection’?",
    "text": "What is a ‘collection’?\nCollections are data structures for storing multiple values.\n\nExample: i8 is a single 8-bit integer value. A vector can store multiple i8s together.",
    "crumbs": [
      "8. Common Collections"
    ]
  },
  {
    "objectID": "slides/08-common_collections.html#what-about-arrays-and-tuples",
    "href": "slides/08-common_collections.html#what-about-arrays-and-tuples",
    "title": "8. Common Collections",
    "section": "What about arrays and tuples?",
    "text": "What about arrays and tuples?\n\nYes, arrays and tuples can hold multiple values\nBut, they are stored on the stack while collections are stored on the heap\n\narray, tuple: fixed size, known at compile time\ncollections: variable size, not known at compile time\n\n\n\nCollections can grow and shrink while the program is running & their size does not need to be known at compile time.",
    "crumbs": [
      "8. Common Collections"
    ]
  },
  {
    "objectID": "slides/08-common_collections.html#common-collections",
    "href": "slides/08-common_collections.html#common-collections",
    "title": "8. Common Collections",
    "section": "Common collections",
    "text": "Common collections\n\nvector: collection of numbers\nstring: collection of characters\nhash map: collection of key-value pairs",
    "crumbs": [
      "8. Common Collections"
    ]
  },
  {
    "objectID": "slides/08-common_collections.html#creating-vectors",
    "href": "slides/08-common_collections.html#creating-vectors",
    "title": "8. Common Collections",
    "section": "Creating vectors",
    "text": "Creating vectors\n\n\nYou can create a vector with new and add values with .push\nlet mut v: Vec&lt;i32&gt; = Vec::new();\n\nv.push(1);\nv.push(2);\nv.push(3);\n\nOr you can create it directly with vec!\nlet v = vec![1, 2, 3];\n\n\nNote the mut in the first case.",
    "crumbs": [
      "8. Common Collections"
    ]
  },
  {
    "objectID": "slides/08-common_collections.html#access-elements",
    "href": "slides/08-common_collections.html#access-elements",
    "title": "8. Common Collections",
    "section": "Access elements",
    "text": "Access elements\n\n\nlet v = vec![1, 2, 3];\n\n\n\n[]\nlet first_element: &i32 = &v[0];\n\nget\nlet first_element: Option&lt;&i32&gt; = v.get(0);\n\n\nFirst method: should be familiar\nSecond method: returns an Option type\nHaving 2 methods means you can control how your program behaves when using an out-of-range index.\nThe first method crashes the program.\nThe second method allows you to handle having Some(value) or None. Maybe you want to",
    "crumbs": [
      "8. Common Collections"
    ]
  },
  {
    "objectID": "slides/08-common_collections.html#access-elements---ownership-borrowing",
    "href": "slides/08-common_collections.html#access-elements---ownership-borrowing",
    "title": "8. Common Collections",
    "section": "Access elements - ownership & borrowing",
    "text": "Access elements - ownership & borrowing\nThis program will not compile\nlet mut v = vec![1, 2, 3, 4, 5];\n\nlet first = &v[0]; // immutable borrow\n\nv.push(6); // mutable borrow\n\nprintln!(\"The first element is: {first}\"); // immutable borrow used\n\nWe’re referencing the first element but updating at the end so you might thing this shoudl be fine.\nThe problem though is that Rust stores vectors in one continuous block of memory. So adding another element may require copying the vector to a new memory location. If that happens, then our reference to the first element will point to a section of deallocated memory.",
    "crumbs": [
      "8. Common Collections"
    ]
  },
  {
    "objectID": "slides/08-common_collections.html#iteration",
    "href": "slides/08-common_collections.html#iteration",
    "title": "8. Common Collections",
    "section": "Iteration",
    "text": "Iteration\n\n\nImmutable vector, immutable references\nlet v = vec![1, 2, 3];\nfor i in &v {\n  println!(\"{i}\");\n}\n// v = [1, 2, 3]\n// output: 1, 2, 3\n\nMutable vector, mutable references\nlet mut v = vec![1, 2, 3];\nfor i in &mut v {\n  *i += 1;\n}\n// v = [2, 3, 4]\n\nfor i in &v {\n    println!(\"{i}\");\n}\n\n// output: 2, 3, 4\n\n\nNote the use of the dereference operator *. We must use this to change the value the mutable reference refers to.",
    "crumbs": [
      "8. Common Collections"
    ]
  },
  {
    "objectID": "slides/08-common_collections.html#vectors-with-multiple-types",
    "href": "slides/08-common_collections.html#vectors-with-multiple-types",
    "title": "8. Common Collections",
    "section": "Vectors with multiple types",
    "text": "Vectors with multiple types\n\n\nenum\nenum SpreadsheetCell {\n  Int(i32),\n  Float(f64),\n  Text(String),\n}\n\nlet row = vec![\n  SpreadsheetCell::Int(3),\n  SpreadsheetCell::Float(10.12),\n];\n\nstruct\nstruct Ex {\n    number: i32,\n    string: String,\n}\n\nlet v = vec![\n    Ex {number: 1, string: String::from(\"string\")},\n    Ex {number: 1, string: String::from(\"2nd string\")},\n];\n\n\nElements of vectors must be all of the same type. To store mutliple types, we need a container that can hold multiple types.",
    "crumbs": [
      "8. Common Collections"
    ]
  },
  {
    "objectID": "slides/08-common_collections.html#what-are-strings",
    "href": "slides/08-common_collections.html#what-are-strings",
    "title": "8. Common Collections",
    "section": "What are Strings?",
    "text": "What are Strings?\n\nCollection of bytes\nIn Rust standard library\nBuilt around vectors\nUTF-8",
    "crumbs": [
      "8. Common Collections"
    ]
  },
  {
    "objectID": "slides/08-common_collections.html#string-vs-str",
    "href": "slides/08-common_collections.html#string-vs-str",
    "title": "8. Common Collections",
    "section": "String vs str",
    "text": "String vs str\n\n\n\nString\n\nstandard library\ndynamic size\nvector\n\n\n\n\nstr\n\nbuilt into the language\nfixed size\nslice of the vector\n\n\n\nMore info: Rust User’s forum – Stack Overflow\n\n\n\nWhen referring to ‘strings’ in Rust, people can mean either a String or str (more typically &str). But they are different types.\nI’ve listed a few of the similarities and differences here and listed a few reference at the bottom. This is still a bit confusing for me but the references helped so I suggest you read them.",
    "crumbs": [
      "8. Common Collections"
    ]
  },
  {
    "objectID": "slides/08-common_collections.html#creating-strings",
    "href": "slides/08-common_collections.html#creating-strings",
    "title": "8. Common Collections",
    "section": "Creating Strings",
    "text": "Creating Strings\n\n\nYou can create a String with new and add values with .push_str\nlet mut s = String::new();\ns.push_str(\"this is\");\ns.push_str(\"a string\");\n\nOr you can create it directly\nlet s1 = String::from(\"this is a string\");\nlet s2 = \"this is a string\".to_string();",
    "crumbs": [
      "8. Common Collections"
    ]
  },
  {
    "objectID": "slides/08-common_collections.html#combining-strings",
    "href": "slides/08-common_collections.html#combining-strings",
    "title": "8. Common Collections",
    "section": "Combining Strings",
    "text": "Combining Strings\n\n\n+\nlet s1 = String::from(\"this is \");\nlet s2 = String::from(\"a string\");\n\nlet s3 = s1 + &s2;\n\nformat!\nlet s1 = String::from(\"this is\");\nlet s2 = String:: from(\"a string\")\n\nlet s3 = format!(\"{s1} ... {s2}!\") // \"this is ... a string!\"\n\n\nUsing the + operator, note that we use a reference to the 2nd string: &s2. This is because how add is defined, see the book for more details.",
    "crumbs": [
      "8. Common Collections"
    ]
  },
  {
    "objectID": "slides/08-common_collections.html#access-elements-1",
    "href": "slides/08-common_collections.html#access-elements-1",
    "title": "8. Common Collections",
    "section": "Access elements",
    "text": "Access elements\nlet s = String::from(\"this is a string\")\nlet first_char = s[0];\n\n\n\n\nComputer says no GIF\n\n\n\n\nSince Strings are built on top of vectors, we may want to get the first character like we would the first element of a vector. But we can’t do that.\nThe reason why is because of how Rust stores strings.",
    "crumbs": [
      "8. Common Collections"
    ]
  },
  {
    "objectID": "slides/08-common_collections.html#internal-representation-of-strings",
    "href": "slides/08-common_collections.html#internal-representation-of-strings",
    "title": "8. Common Collections",
    "section": "Internal representation of Strings",
    "text": "Internal representation of Strings\n\n\nWrapper around Vec&lt;u8&gt;\nVector of bytes\nUTF-8\n\n\n\nlet hello = String::from(\"hello\");\nlet konichiwa = String::from(\"こんにちは\");\n\nprintln!(\"Hello bytes: {}\", hello.len()); // 5\nprintln!(\"Konichiwa bytes:{}\", konichiwa.len()); // 15\n\n\nRust Playground\n\n\nTo understand why we can’t index into strings we need to know how Strings are represented in Rust. Rust stores strings as a vector of bytes, encoded in UTF-8.\nExample: the String ‘hello’ in English and Japanese.\nOn the surface, it looks like they would both have legnth 5. But, because of how strings are stored, the lengths are very different.\nHuman languages have a lot of variety so there is no ‘correct’ way to index into strings. The best we can do is take slices of a string …",
    "crumbs": [
      "8. Common Collections"
    ]
  },
  {
    "objectID": "slides/08-common_collections.html#string-slices",
    "href": "slides/08-common_collections.html#string-slices",
    "title": "8. Common Collections",
    "section": "String slices",
    "text": "String slices\n\nlet hello = String::from(\"hello\");\nprintln!(\"Hello first: {}\", &hello[0..1]); // h\n\n\nlet konichiwa = String::from(\"こんにちは\");\nprintln!(\"Konichiwa first: {}\", &konichiwa[0..1]); //error\n\n\nRust Playground\n\n\nWhile we can’t index into strings at specific indices, we can use a range of indices to get string slices.\nSo if we specify the range to get the first element, we get ‘h’ as expected.\nHowever, that doesn’t always work. Some languages need more than 1 byte to store a character. We need to know the language so we can slice at the boundaries of characters. Otherwise we get an error.",
    "crumbs": [
      "8. Common Collections"
    ]
  },
  {
    "objectID": "slides/08-common_collections.html#iteration-1",
    "href": "slides/08-common_collections.html#iteration-1",
    "title": "8. Common Collections",
    "section": "Iteration",
    "text": "Iteration\n\n\n.chars()\nlet hello = String::from(\"hello\");\nlet konichiwa = String::from(\"こんにちは\");\n\nfor c in hello.chars() {\n    println!(\"{c}\");\n} // h, e, l, l, o\n\nfor c in konichiwa.chars() {\n    println!(\"{c}\");\n} // こ, ん, に, ち, は\n\n.bytes()\nlet hello = String::from(\"hello\");\nlet konichiwa = String::from(\"こんにちは\");\n\nfor b in hello.bytes() {\n    println!(\"{b}\");\n} // 104, 101, ...\n\nfor b in konichiwa.bytes() {\n    println!(\"{b}\");\n} // 227, 129, ...\n\n\nRust Playground - chars – Rust Playground - bytes",
    "crumbs": [
      "8. Common Collections"
    ]
  },
  {
    "objectID": "slides/08-common_collections.html#creating-hash-maps",
    "href": "slides/08-common_collections.html#creating-hash-maps",
    "title": "8. Common Collections",
    "section": "Creating hash maps",
    "text": "Creating hash maps\nYou can create a hash map with new and add values with .insert\nuse std::collections::HashMap;\n\nlet mut scores = HashMap::new();\n\nscores.insert(String::from(\"Red\"), 10);\nscores.insert(String::from(\"Blue\"), 20);\n\nNote the use here. Since hash maps are not used as often as vectors or strings we need to explicitly import them.",
    "crumbs": [
      "8. Common Collections"
    ]
  },
  {
    "objectID": "slides/08-common_collections.html#access-elements-2",
    "href": "slides/08-common_collections.html#access-elements-2",
    "title": "8. Common Collections",
    "section": "Access elements",
    "text": "Access elements\nuse std::collections::HashMap;\n\nlet mut scores = HashMap::new();\n\nscores.insert(String::from(\"Red\"), 10);\nscores.insert(String::from(\"Blue\"), 20);\n\nlet blue_team = String::from(\"Blue\");\nlet blue_score = scores.get(&blue_team).copied().unwrap_or(0); // 20\n\n\n\nget returns an Option&lt;&V&gt;\ncopied returns an Option&lt;i32&gt; instead of Option&lt;&i32&gt;\nunwrap_or returns 0 if there is no entry for \"Blue\"\n\n\n\n\nThe extra calls after get here are to get at the underlying value.\n\nget returns an Optionwe copy it to get an Option of type i32",
    "crumbs": [
      "8. Common Collections"
    ]
  },
  {
    "objectID": "slides/08-common_collections.html#iteration-2",
    "href": "slides/08-common_collections.html#iteration-2",
    "title": "8. Common Collections",
    "section": "Iteration",
    "text": "Iteration\nuse std::collections::HashMap;\n\nlet mut scores = HashMap::new();\n\nscores.insert(String::from(\"Red\"), 10);\nscores.insert(String::from(\"Blue\"), 20);\n\nfor (key, value) in &scores {\n  println!(\"{key}: {value}\");\n} // Red: 10, Blue: 20\n\nOrder is arbitrary\n\n\nFor iteration we loop across the key-value pairs.\nNote: the order of they key-value pairs when iterating is arbitrary. We can’t assume it will be in the same order they were inserted in.",
    "crumbs": [
      "8. Common Collections"
    ]
  },
  {
    "objectID": "slides/08-common_collections.html#updating---overwrite",
    "href": "slides/08-common_collections.html#updating---overwrite",
    "title": "8. Common Collections",
    "section": "Updating - overwrite",
    "text": "Updating - overwrite\nuse std::collections::HashMap;\n\nlet mut scores = HashMap::new()\n\nscores.insert(String::from(\"Blue\"), 10);\nscores.insert(String::from(\"Blue\"), 25);\n\nWe can update a hash map in 3 different ways. The first is to just overwrite the existing value.\nBecause “Blue” is already a key, the 2nd insert will change the value. Each key is unique.",
    "crumbs": [
      "8. Common Collections"
    ]
  },
  {
    "objectID": "slides/08-common_collections.html#updating---add-if-not-present",
    "href": "slides/08-common_collections.html#updating---add-if-not-present",
    "title": "8. Common Collections",
    "section": "Updating - add if not present",
    "text": "Updating - add if not present\nuse std::collections::HashMap;\n\nlet mut scores = HashMap::new();\nscores.insert(String::from(\"Blue\"), 10);\n\nscores.entry(String::from(\"Red\")).or_insert(50); // added\nscores.entry(String::from(\"Blue\")).or_insert(50); // skipped\n\nSometimes we may want to add a key-value pair only if that key doesn’t exist yet.\nWe do that with entry and or_insert. In this example, the \"Red\": 50 will be inserted and the “Blue” entry will be left as is.",
    "crumbs": [
      "8. Common Collections"
    ]
  },
  {
    "objectID": "slides/08-common_collections.html#updating---modify-existing-value",
    "href": "slides/08-common_collections.html#updating---modify-existing-value",
    "title": "8. Common Collections",
    "section": "Updating - modify existing value",
    "text": "Updating - modify existing value\nuse std::collections::HashMap;\n\nlet text = \"hello world wonderful world\";\n\nlet mut map = HashMap::new();\n\nfor word in text.split_whitespace() {\n  let count = map.entry(word).or_insert(0);\n  *count += 1;\n}\nprintln!(\"{map:?}\"); // {\"world\": 2, \"hello\": 1, \"wonderful\": 1}",
    "crumbs": [
      "8. Common Collections"
    ]
  },
  {
    "objectID": "slides/01-getting_started.html#rust",
    "href": "slides/01-getting_started.html#rust",
    "title": "1. Getting Started",
    "section": "Rust",
    "text": "Rust\n\nA language empowering everyone to build reliable and efficient software.\n\n\nLet’s get started.\nRust says it’s a ‘language empowering …’ The key words that stick out for me are ‘reliable’ and ‘efficient.’\nIf you’re like me, those are the main selling points you’ve heard related to rust. Rust is efficient, both in terms of run time and development time. And Rust is reliable, eliminating bugs related to memory management that come up in languages like C.\nBy the end of this book, we should have an idea of how well Rust holds up to those statements.",
    "crumbs": [
      "1. Getting Started"
    ]
  },
  {
    "objectID": "slides/01-getting_started.html#set-up",
    "href": "slides/01-getting_started.html#set-up",
    "title": "1. Getting Started",
    "section": "Set up",
    "text": "Set up\n\nInstall Rust\nChoose an editor\nInstall extensions\n\n\nI assume you can install Rust but if you have issues we can help shortly.\nIt’s likely many of us have only used R and RStudio. If that’s the case, I want to point out some differences you’ll encounter.\nBoth R and RStudio come with everything you need to write R code. However, with other languges and editors, you often need to install tools specific to that language. For example, language servers, debuggers, and package managers. You most definitely want to install the Rust tooling for whatever editor you use.\nIf you aren’t sure, I recommend using Visual Studio Code with the rust-analyzer extension. You will also need an extension with debugging support. You can find a link in the rust-analyzer extension. Again, if you need help with this, we can get to that shortly.",
    "crumbs": [
      "1. Getting Started"
    ]
  },
  {
    "objectID": "slides/01-getting_started.html#hello-world",
    "href": "slides/01-getting_started.html#hello-world",
    "title": "1. Getting Started",
    "section": "Hello, World",
    "text": "Hello, World\nfn main() {\n    println!(\"Hello, world!\");\n}\n\nfn main() is required in main.rs\nThe ! in println! means macro\nThe ; is required\n\n\nThis is the obligatory hello world. Since this is a simple program, it’s clear what’s going on.\nBut there are some details worth pointing out.\nEvery rust program has a main.rs file with a main function in it. This is the entrypoint to the program, the first thing that get’s run.\nThe ! in println! means println is a macro. A macro is sort of like a function. That’s a sufficient understanding for now. We’ll get to the details of what a macro is later in the book.\nLastly, note the ; which indicated the end of an expression. This is generally required for every statement you write.",
    "crumbs": [
      "1. Getting Started"
    ]
  },
  {
    "objectID": "slides/01-getting_started.html#compile-and-run",
    "href": "slides/01-getting_started.html#compile-and-run",
    "title": "1. Getting Started",
    "section": "Compile and run",
    "text": "Compile and run\nrustc main.rs\n./main\n\nRust is a compiled language so we have to run the compiler rustc first.\nIf you’ve never used a compiled language before, compiling is the process of translating the Rust code you write into a language the computer can read. With interpreted languages like R or Python, this translation happens on the fly. But with a compiled language, you have to translate the program before it can run.\nOnce compiled, you’ll have an executable file that you can now run. On Mac/Linux, it will be main. On Windows, it will be main.exe.",
    "crumbs": [
      "1. Getting Started"
    ]
  },
  {
    "objectID": "slides/01-getting_started.html#cargo",
    "href": "slides/01-getting_started.html#cargo",
    "title": "1. Getting Started",
    "section": "Cargo",
    "text": "Cargo\n[package]\nname = \"hello_cargo\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\n\nUnlike R, where installing dependencies is built into the language, Rust has a separate program for this called cargo. With cargo, you define your dependencies, among other things, in a TOML file.",
    "crumbs": [
      "1. Getting Started"
    ]
  },
  {
    "objectID": "slides/01-getting_started.html#cargo-1",
    "href": "slides/01-getting_started.html#cargo-1",
    "title": "1. Getting Started",
    "section": "Cargo",
    "text": "Cargo\n\n\n\n\ncargo new project_name\nCargo.toml\ncargo.lock\n\n\n\nproject_name/.Rproj\nDESCRIPTION\nrenv.lock\n\n\n\n\nMore than installing dependencies though, cargo helps you manage your Rust projects. It let’s you create projects, install dependencies, compile, and run your project.\nA cargo project is like an RStudio project.\nCargo.toml is like DESCRIPTION in an R package.\nAnd cargo tracks dependency versions with cargo.lock, which is like renv.lock.",
    "crumbs": [
      "1. Getting Started"
    ]
  },
  {
    "objectID": "slides/01-getting_started.html#discussion",
    "href": "slides/01-getting_started.html#discussion",
    "title": "1. Getting Started",
    "section": "Discussion",
    "text": "Discussion",
    "crumbs": [
      "1. Getting Started"
    ]
  },
  {
    "objectID": "slides/12-an_io_project_building_a_command_line_program.html#features-of-the-program",
    "href": "slides/12-an_io_project_building_a_command_line_program.html#features-of-the-program",
    "title": "12. An I/O Project: Building a Command Line Program",
    "section": "Features of the Program",
    "text": "Features of the Program\n\n\nCommand-line argument parsing.\nFile reading and searching for strings.\nError handling and modularity.\nEnvironment variable configuration.\nPrinting to standard error.",
    "crumbs": [
      "12. An I/O Project: Building a Command Line Program"
    ]
  },
  {
    "objectID": "slides/12-an_io_project_building_a_command_line_program.html#create-a-new-project",
    "href": "slides/12-an_io_project_building_a_command_line_program.html#create-a-new-project",
    "title": "12. An I/O Project: Building a Command Line Program",
    "section": "Create a New Project",
    "text": "Create a New Project\nIn your Shell/ terminal, run:\n\ncargo new minigrep\ncd minigrep",
    "crumbs": [
      "12. An I/O Project: Building a Command Line Program"
    ]
  },
  {
    "objectID": "slides/12-an_io_project_building_a_command_line_program.html#initial-code",
    "href": "slides/12-an_io_project_building_a_command_line_program.html#initial-code",
    "title": "12. An I/O Project: Building a Command Line Program",
    "section": "Initial Code",
    "text": "Initial Code\nIn src/main.rs:\n\n\nCollect command-line arguments.\n\n\nuse std::env;\nfn main() {\n    let args: Vec&lt;String&gt; = env::args().collect();\n    dbg!(args);\n}\n\n\nUse dbg! for debugging.\n\n\nCargo Run\n\n$ cargo run\n[src/main.rs:5:5] args = [\n    \"target/debug/minigrep\",\n]\n\n$ cargo run -- needle haystack\n[src/main.rs:5:5] args = [\n    \"target/debug/minigrep\",\n    \"needle\",\n    \"haystack\",\n]",
    "crumbs": [
      "12. An I/O Project: Building a Command Line Program"
    ]
  },
  {
    "objectID": "slides/12-an_io_project_building_a_command_line_program.html#parsing-arguments",
    "href": "slides/12-an_io_project_building_a_command_line_program.html#parsing-arguments",
    "title": "12. An I/O Project: Building a Command Line Program",
    "section": "Parsing Arguments",
    "text": "Parsing Arguments\nSave Arguments in Variables\nuse std::env;\nfn main() {\n    let args: Vec&lt;String&gt; = env::args().collect();\n    let query = &args[1];\n    let file_path = &args[2];\n\n    println!(\"Searching for {query}\");\n    println!(\"In file {file_path}\");\n}\nCargo Run\n\ncargo run -- test sample.txt\nSearching for test\nIn file sample.txt",
    "crumbs": [
      "12. An I/O Project: Building a Command Line Program"
    ]
  },
  {
    "objectID": "slides/12-an_io_project_building_a_command_line_program.html#reading-files",
    "href": "slides/12-an_io_project_building_a_command_line_program.html#reading-files",
    "title": "12. An I/O Project: Building a Command Line Program",
    "section": "Reading Files",
    "text": "Reading Files\nUse fs::read_to_string\nuse std::env;\nuse std::fs;\nfn main() {\n    let args: Vec&lt;String&gt; = env::args().collect();\n    let file_path = &args[2];\n\n    let contents = fs::read_to_string(file_path)\n        .expect(\"Should have been able to read the file\");\n\n    println!(\"With text:\\n{contents}\");\n}\nCargo Run\n\ncargo run -- the poem.txt\nSearching for the\nIn file poem.txt\nWith text:\nI'm nobody! Who are you?\nAre you nobody, too?\nThen there's a pair of us - don't tell!\nThey'd banish us, you know.\n\nHow dreary to be somebody!\nHow public, like a frog\nTo tell your name the livelong day\nTo an admiring bog!",
    "crumbs": [
      "12. An I/O Project: Building a Command Line Program"
    ]
  },
  {
    "objectID": "slides/12-an_io_project_building_a_command_line_program.html#extracting-the-argument-parser",
    "href": "slides/12-an_io_project_building_a_command_line_program.html#extracting-the-argument-parser",
    "title": "12. An I/O Project: Building a Command Line Program",
    "section": "Extracting the Argument Parser",
    "text": "Extracting the Argument Parser\nsrc/main.rs should now contain parse_config logic:\nuse std::env;\nuse std::fs;\n\nfn main() {\n    let args: Vec&lt;String&gt; = env::args().collect();\n\n    let (query, file_path) = parse_config(&args);\n\n    println!(\"Searching for {query}\");\n    println!(\"In file {file_path}\");\n\n    let contents = fs::read_to_string(file_path)\n        .expect(\"Should have been able to read the file\");\n\n    println!(\"With text:\\n{contents}\");\n}\n\nfn parse_config(args: &[String]) -&gt; (&str, &str) {\n    let query = &args[1];\n    let file_path = &args[2];\n\n    (query, file_path)\n}",
    "crumbs": [
      "12. An I/O Project: Building a Command Line Program"
    ]
  },
  {
    "objectID": "slides/12-an_io_project_building_a_command_line_program.html#grouping-configuration-variables",
    "href": "slides/12-an_io_project_building_a_command_line_program.html#grouping-configuration-variables",
    "title": "12. An I/O Project: Building a Command Line Program",
    "section": "Grouping Configuration Variables",
    "text": "Grouping Configuration Variables\nAt the moment we have a tuple which we breakdown into individual parts again.\nuse std::env;\nuse std::fs;\n\nfn main() {\n    let args: Vec&lt;String&gt; = env::args().collect();\n\n    let config = parse_config(&args);\n\n    println!(\"Searching for {}\", config.query);\n    println!(\"In file {}\", config.file_path);\n\n    let contents = fs::read_to_string(config.file_path)\n        .expect(\"Should have been able to read the file\");\n\n    println!(\"With text:\\n{contents}\");\n}\n\n// Add struct\nstruct Config { \n    query: String, \n    file_path: String,\n}\n\n// Update parse_config to handle struct\nfn parse_config(args: &[String]) -&gt; Config {\nlet query = args[1].clone();\nlet file_path = args[2].clone();\n\nConfig { query, file_path }\n}",
    "crumbs": [
      "12. An I/O Project: Building a Command Line Program"
    ]
  },
  {
    "objectID": "slides/12-an_io_project_building_a_command_line_program.html#checkpoint",
    "href": "slides/12-an_io_project_building_a_command_line_program.html#checkpoint",
    "title": "12. An I/O Project: Building a Command Line Program",
    "section": "Checkpoint",
    "text": "Checkpoint\nWhat we’ve done so far:\n\n\nUpdated main to place the instance of Config returned by parse_config into a variable named config.\nReplaced the separate query and file_path variables with the fields on the Config struct.\nEnhanced code clarity by indicating that query and file_path are related.\nClearly expressed their purpose as configuring how the program operates.\nEnsured any code using these values finds them in the config instance in appropriately named fields.",
    "crumbs": [
      "12. An I/O Project: Building a Command Line Program"
    ]
  },
  {
    "objectID": "slides/12-an_io_project_building_a_command_line_program.html#creating-a-constructor-for-config",
    "href": "slides/12-an_io_project_building_a_command_line_program.html#creating-a-constructor-for-config",
    "title": "12. An I/O Project: Building a Command Line Program",
    "section": "Creating a Constructor for Config",
    "text": "Creating a Constructor for Config\nuse std::env;\nuse std::fs;\n\nfn main() {\n    let args: Vec&lt;String&gt; = env::args().collect();\n\n    let config = Config::new(&args);\n\n    println!(\"Searching for {}\", config.query);\n    println!(\"In file {}\", config.file_path);\n\n    let contents = fs::read_to_string(config.file_path)\n        .expect(\"Should have been able to read the file\");\n\n    println!(\"With text:\\n{contents}\");\n}\n\nstruct Config {\n    query: String,\n    file_path: String,\n}\n\n// Add implementation `parse_config` -&gt; `new`\nimpl Config {\n    fn new(args: &[String]) -&gt; Config {\n        let query = args[1].clone();\n        let file_path = args[2].clone();\n\n        Config { query, file_path }\n    }\n}",
    "crumbs": [
      "12. An I/O Project: Building a Command Line Program"
    ]
  },
  {
    "objectID": "slides/12-an_io_project_building_a_command_line_program.html#fixing-the-error-handling",
    "href": "slides/12-an_io_project_building_a_command_line_program.html#fixing-the-error-handling",
    "title": "12. An I/O Project: Building a Command Line Program",
    "section": "Fixing the Error Handling",
    "text": "Fixing the Error Handling\nLet’s improve the error message:\nuse std::env;\nuse std::fs;\n\nfn main() {\n    let args: Vec&lt;String&gt; = env::args().collect();\n\n    let config = Config::new(&args);\n\n    println!(\"Searching for {}\", config.query);\n    println!(\"In file {}\", config.file_path);\n\n    let contents = fs::read_to_string(config.file_path)\n        .expect(\"Should have been able to read the file\");\n\n    println!(\"With text:\\n{contents}\");\n}\n\nstruct Config {\n    query: String,\n    file_path: String,\n}\n\nimpl Config {\n    fn new(args: &[String]) -&gt; Config {\n        if args.len() &lt; 3 {\n            panic!(\"not enough arguments\");\n        }\n\n        let query = args[1].clone();\n        let file_path = args[2].clone();\n\n        Config { query, file_path }\n    }\n}\nRun the code to see what the error looks like.",
    "crumbs": [
      "12. An I/O Project: Building a Command Line Program"
    ]
  },
  {
    "objectID": "slides/12-an_io_project_building_a_command_line_program.html#returning-a-result",
    "href": "slides/12-an_io_project_building_a_command_line_program.html#returning-a-result",
    "title": "12. An I/O Project: Building a Command Line Program",
    "section": "Returning a Result",
    "text": "Returning a Result\n\n\nChange function name from new to build\nConvert Err to text about thread 'main' and RUST_BACKTRACE\n\n\nimpl Config {\n    fn build(args: &[String]) -&gt; Result&lt;Config, &'static str&gt; {\n        if args.len() &lt; 3 {\n            return Err(\"not enough arguments\");\n        }\n\n        let query = args[1].clone();\n        let file_path = args[2].clone();\n\n        Ok(Config { query, file_path })\n    }\n}\n\n\nUpdate main to handle Result returned by Config::build.\n\n\nuse std::process;\n\nfn main() {\n    let args: Vec&lt;String&gt; = env::args().collect();\n\n    let config = Config::build(&args).unwrap_or_else(|err| {\n        println!(\"Problem parsing arguments: {err}\");\n        process::exit(1);\n    });\n\n    // --snip--",
    "crumbs": [
      "12. An I/O Project: Building a Command Line Program"
    ]
  },
  {
    "objectID": "slides/12-an_io_project_building_a_command_line_program.html#extracting-logic-from-main",
    "href": "slides/12-an_io_project_building_a_command_line_program.html#extracting-logic-from-main",
    "title": "12. An I/O Project: Building a Command Line Program",
    "section": "Extracting Logic from main",
    "text": "Extracting Logic from main\n\n\nExtract a function named run to handle non-error logic\n\n\nfn main() {\n    // --snip--\n    println!(\"Searching for {}\", config.query);\n    println!(\"In file {}\", config.file_path);\n\n    run(config);\n}\n\nfn run(config: Config) {\n    let contents = fs::read_to_string(config.file_path)\n        .expect(\"Should have been able to read the file\");\n\n    println!(\"With text:\\n{contents}\");\n}\n// --snip--\n\n\nThe run function takes the Config instance as an argument.",
    "crumbs": [
      "12. An I/O Project: Building a Command Line Program"
    ]
  },
  {
    "objectID": "slides/12-an_io_project_building_a_command_line_program.html#improve-error-handling-from-the-run-function",
    "href": "slides/12-an_io_project_building_a_command_line_program.html#improve-error-handling-from-the-run-function",
    "title": "12. An I/O Project: Building a Command Line Program",
    "section": "Improve Error handling from the run Function",
    "text": "Improve Error handling from the run Function\nuse std::error::Error;\n\n// --snip--\n\nfn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {\n    let contents = fs::read_to_string(config.file_path)?;\n\n    println!(\"With text:\\n{contents}\");\n\n    Ok(())\n}\n\n\nChanged the return type of the run function to Result&lt;(), Box&lt;dyn Error&gt;&gt;.\nReplaced the expect call with the ? operator to propagate errors to the caller without panicking.\nUpdated the run function to explicitly return Ok(()) in the success case.\n\n\nSuggestions from the compiler: let _ = run(config);",
    "crumbs": [
      "12. An I/O Project: Building a Command Line Program"
    ]
  },
  {
    "objectID": "slides/12-an_io_project_building_a_command_line_program.html#handling-errors-returned-from-run-in-main",
    "href": "slides/12-an_io_project_building_a_command_line_program.html#handling-errors-returned-from-run-in-main",
    "title": "12. An I/O Project: Building a Command Line Program",
    "section": "Handling Errors Returned from run in main",
    "text": "Handling Errors Returned from run in main\nCheck error from run in main\nfn main() {\n    // --snip--\n\n    println!(\"Searching for {}\", config.query);\n    println!(\"In file {}\", config.file_path);\n\n    if let Err(e) = run(config) {\n        println!(\"Application error: {e}\");\n        process::exit(1);\n    }\n}",
    "crumbs": [
      "12. An I/O Project: Building a Command Line Program"
    ]
  },
  {
    "objectID": "slides/12-an_io_project_building_a_command_line_program.html#splitting-code-into-a-library-crate",
    "href": "slides/12-an_io_project_building_a_command_line_program.html#splitting-code-into-a-library-crate",
    "title": "12. An I/O Project: Building a Command Line Program",
    "section": "Splitting Code into a Library Crate",
    "text": "Splitting Code into a Library Crate\n\n\nSplit the program into main.rs and lib.rs:\nCreate lib.rs:\n\nMove all program logic, such as the Config struct, its methods, and the run function, into lib.rs.\n\nKeep Minimal Code in main.rs:\n\nLeave only the command-line argument parsing, configuration setup, and error handling in main.rs.\n\n\n\n\nminigrep/\n├── src/\n│   ├── main.rs   // Contains the entry point and calls logic from lib.rs\n│   ├── lib.rs    // Contains the program logic (e.g., Config, run function)\n├── Cargo.toml    // Project configuration",
    "crumbs": [
      "12. An I/O Project: Building a Command Line Program"
    ]
  },
  {
    "objectID": "slides/12-an_io_project_building_a_command_line_program.html#srclib.rs",
    "href": "slides/12-an_io_project_building_a_command_line_program.html#srclib.rs",
    "title": "12. An I/O Project: Building a Command Line Program",
    "section": "src/lib.rs",
    "text": "src/lib.rs\nLiberal use of the pub keyword:\nuse std::error::Error;\nuse std::fs;\n\npub struct Config {\n    pub query: String,\n    pub file_path: String,\n}\n\nimpl Config {\n    pub fn build(args: &[String]) -&gt; Result&lt;Config, &'static str&gt; {\n\n        if args.len() &lt; 3 {\n            return Err(\"not enough arguments\");\n        }\n\n        let query = args[1].clone();\n        let file_path = args[2].clone();\n\n        Ok(Config { query, file_path })\n    }\n}\n\npub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {\n\n    let contents = fs::read_to_string(config.file_path)?;\n\n    println!(\"With text:\\n{contents}\");\n\n    Ok(())\n}",
    "crumbs": [
      "12. An I/O Project: Building a Command Line Program"
    ]
  },
  {
    "objectID": "slides/12-an_io_project_building_a_command_line_program.html#srcmainrs",
    "href": "slides/12-an_io_project_building_a_command_line_program.html#srcmainrs",
    "title": "12. An I/O Project: Building a Command Line Program",
    "section": "src/main/rs",
    "text": "src/main/rs\nuse std::env;\nuse std::process;\n\nuse minigrep::Config;\n\nfn main() {\n    let args: Vec&lt;String&gt; = env::args().collect();\n\n    let config = Config::build(&args).unwrap_or_else(|err| {\n        println!(\"Problem parsing arguments: {err}\");\n        process::exit(1);\n    });\n\n    if let Err(e) = minigrep::run(config) {\n        println!(\"Application error: {e}\");\n        process::exit(1);\n    }\n}",
    "crumbs": [
      "12. An I/O Project: Building a Command Line Program"
    ]
  },
  {
    "objectID": "slides/12-an_io_project_building_a_command_line_program.html#writing-a-failing-test",
    "href": "slides/12-an_io_project_building_a_command_line_program.html#writing-a-failing-test",
    "title": "12. An I/O Project: Building a Command Line Program",
    "section": "Writing a Failing Test",
    "text": "Writing a Failing Test\nRemove println! statements from main and lib\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn one_result() {\n        let query = \"duct\";\n        let contents = \"\\\nRust:\nsafe, fast, productive.\nPick three.\";\n\n        assert_eq!(vec![\"safe, fast, productive.\"], search(query, contents));\n    }\n}\nCreate search function:\npub fn search&lt;'a&gt;(query: &str, contents: &'a str) -&gt; Vec&lt;&'a str&gt; {\n    vec![]\n}\n\nBuild and test",
    "crumbs": [
      "12. An I/O Project: Building a Command Line Program"
    ]
  },
  {
    "objectID": "slides/12-an_io_project_building_a_command_line_program.html#writing-code-to-pass-the-test",
    "href": "slides/12-an_io_project_building_a_command_line_program.html#writing-code-to-pass-the-test",
    "title": "12. An I/O Project: Building a Command Line Program",
    "section": "Writing Code to Pass the Test",
    "text": "Writing Code to Pass the Test\n\n\nIterate through lines method\nSearch each line\nStore matching lines\n\n\npub fn search&lt;'a&gt;(query: &str, contents: &'a str) -&gt; Vec&lt;&'a str&gt; {\n    let mut results = Vec::new(); // Step 3\n\n    for line in contents.lines() { // Step 1\n        if line.contains(query) { //Step 2\n            results.push(line); //Step 3\n        }\n    }\n\n    results // Step 3\n}",
    "crumbs": [
      "12. An I/O Project: Building a Command Line Program"
    ]
  },
  {
    "objectID": "slides/12-an_io_project_building_a_command_line_program.html#using-the-search-function-in-the-run-function",
    "href": "slides/12-an_io_project_building_a_command_line_program.html#using-the-search-function-in-the-run-function",
    "title": "12. An I/O Project: Building a Command Line Program",
    "section": "Using the search Function in the run Function",
    "text": "Using the search Function in the run Function\npub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {\n    let contents = fs::read_to_string(config.file_path)?;\n\n    for line in search(&config.query, &contents) {\n        println!(\"{line}\");\n    }\n\n    Ok(())\n}\nTest with poem.txt\n\n\nfrog\nbody\nmonomorphization\n\n\n\ncargo run -- frog poem.txt",
    "crumbs": [
      "12. An I/O Project: Building a Command Line Program"
    ]
  },
  {
    "objectID": "slides/12-an_io_project_building_a_command_line_program.html#writing-a-failing-test-1",
    "href": "slides/12-an_io_project_building_a_command_line_program.html#writing-a-failing-test-1",
    "title": "12. An I/O Project: Building a Command Line Program",
    "section": "Writing a Failing Test",
    "text": "Writing a Failing Test\nCase-Insensitive search Function\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn case_sensitive() {\n        let query = \"duct\";\n        let contents = \"\\\nRust:\nsafe, fast, productive.\nPick three.\nDuct tape.\";\n\n        assert_eq!(vec![\"safe, fast, productive.\"], search(query, contents));\n    }\n\n    #[test]\n    fn case_insensitive() {\n        let query = \"rUsT\";\n        let contents = \"\\\nRust:\nsafe, fast, productive.\nPick three.\nTrust me.\";\n\n        assert_eq!(\n            vec![\"Rust:\", \"Trust me.\"],\n            search_case_insensitive(query, contents)\n        );\n    }\n}",
    "crumbs": [
      "12. An I/O Project: Building a Command Line Program"
    ]
  },
  {
    "objectID": "slides/12-an_io_project_building_a_command_line_program.html#implementing-search_case_insensitive",
    "href": "slides/12-an_io_project_building_a_command_line_program.html#implementing-search_case_insensitive",
    "title": "12. An I/O Project: Building a Command Line Program",
    "section": "Implementing search_case_insensitive",
    "text": "Implementing search_case_insensitive\npub fn search_case_insensitive&lt;'a&gt;(\n    query: &str,\n    contents: &'a str,\n) -&gt; Vec&lt;&'a str&gt; {\n    let query = query.to_lowercase();\n    let mut results = Vec::new();\n\n    for line in contents.lines() {\n        if line.to_lowercase().contains(&query) {\n            results.push(line);\n        }\n    }\n\n    results\n}\nTest!",
    "crumbs": [
      "12. An I/O Project: Building a Command Line Program"
    ]
  },
  {
    "objectID": "slides/12-an_io_project_building_a_command_line_program.html#update-config-struct-and-run-function",
    "href": "slides/12-an_io_project_building_a_command_line_program.html#update-config-struct-and-run-function",
    "title": "12. An I/O Project: Building a Command Line Program",
    "section": "Update Config struct and run function",
    "text": "Update Config struct and run function\nConfig\npub struct Config {\n    pub query: String,\n    pub file_path: String,\n    pub ignore_case: bool,\n}\nrun\npub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {\n    let contents = fs::read_to_string(config.file_path)?;\n\n    let results = if config.ignore_case {\n        search_case_insensitive(&config.query, &contents)\n    } else {\n        search(&config.query, &contents)\n    };\n\n    for line in results {\n        println!(\"{line}\");\n    }\n\n    Ok(())\n}",
    "crumbs": [
      "12. An I/O Project: Building a Command Line Program"
    ]
  },
  {
    "objectID": "slides/12-an_io_project_building_a_command_line_program.html#check-for-environment-variable",
    "href": "slides/12-an_io_project_building_a_command_line_program.html#check-for-environment-variable",
    "title": "12. An I/O Project: Building a Command Line Program",
    "section": "Check for environment variable",
    "text": "Check for environment variable\nIn 'src/lib.rs:\nuse std::env;\n// --snip--\n\nimpl Config {\n    pub fn build(args: &[String]) -&gt; Result&lt;Config, &'static str&gt; {\n        if args.len() &lt; 3 {\n            return Err(\"not enough arguments\");\n        }\n\n        let query = args[1].clone();\n        let file_path = args[2].clone();\n\n        let ignore_case = env::var(\"IGNORE_CASE\").is_ok();\n\n        Ok(Config {\n            query,\n            file_path,\n            ignore_case,\n        })\n    }\n}\nTest using enviroment variable:\n\nIGNORE_CASE=1 cargo run -- to poem.txt",
    "crumbs": [
      "12. An I/O Project: Building a Command Line Program"
    ]
  },
  {
    "objectID": "slides/12-an_io_project_building_a_command_line_program.html#checking-errors-are-written",
    "href": "slides/12-an_io_project_building_a_command_line_program.html#checking-errors-are-written",
    "title": "12. An I/O Project: Building a Command Line Program",
    "section": "Checking errors are written",
    "text": "Checking errors are written\n\n\nObserve how minigrep currently writes all output, including errors, to standard output.\n\n\ncargo run &gt; output.txt\n\n\nWe want to:\n\nSave the error message to a file.\nMake error visible on the screen",
    "crumbs": [
      "12. An I/O Project: Building a Command Line Program"
    ]
  },
  {
    "objectID": "slides/12-an_io_project_building_a_command_line_program.html#printing-errors-to-standard-error",
    "href": "slides/12-an_io_project_building_a_command_line_program.html#printing-errors-to-standard-error",
    "title": "12. An I/O Project: Building a Command Line Program",
    "section": "Printing Errors to Standard Error",
    "text": "Printing Errors to Standard Error\nChange the two places we used println! to print errors with eprintln! instead.\nIn src/main.rs:\nfn main() {\n    let args: Vec&lt;String&gt; = env::args().collect();\n\n    let config = Config::build(&args).unwrap_or_else(|err| {\n        eprintln!(\"Problem parsing arguments: {err}\");\n        process::exit(1);\n    });\n\n    if let Err(e) = minigrep::run(config) {\n        eprintln!(\"Application error: {e}\");\n        process::exit(1);\n    }\n}",
    "crumbs": [
      "12. An I/O Project: Building a Command Line Program"
    ]
  },
  {
    "objectID": "slides/12-an_io_project_building_a_command_line_program.html#summary",
    "href": "slides/12-an_io_project_building_a_command_line_program.html#summary",
    "title": "12. An I/O Project: Building a Command Line Program",
    "section": "Summary",
    "text": "Summary\nKey Concepts Used\n\n\nArgument parsing.\nFile reading and handling.\nModular design.\nError handling.\nEnvironment variables.",
    "crumbs": [
      "12. An I/O Project: Building a Command Line Program"
    ]
  },
  {
    "objectID": "slides/07-managing_growing_projects_with_packages_crates_and_modules.html#key-concepts",
    "href": "slides/07-managing_growing_projects_with_packages_crates_and_modules.html#key-concepts",
    "title": "7. Managing Growing Projects with Packages, Crates, and Modules",
    "section": "Key Concepts",
    "text": "Key Concepts\n\nPackage: A Cargo feature that lets you build, test and share crates. Defined by a Cargo.toml file.\nCrate: A tree of modules that produces a library or executable. Rust’s compilation unit.\n\nBinary crate: An executable with a main function as an entry point.\nLibrary crate: A crate that can be used by other crates.\n\nModule: A way to organize code and control scope and visibility.\nPaths: A way of naming an item, such as a struct, function, or module.",
    "crumbs": [
      "7. Managing Growing Projects with Packages, Crates, and Modules"
    ]
  },
  {
    "objectID": "slides/07-managing_growing_projects_with_packages_crates_and_modules.html#setting-up-a-package",
    "href": "slides/07-managing_growing_projects_with_packages_crates_and_modules.html#setting-up-a-package",
    "title": "7. Managing Growing Projects with Packages, Crates, and Modules",
    "section": "Setting Up a Package",
    "text": "Setting Up a Package\n$ cargo new my_project\n$ cd my_project\n\nCreates a new package with a Cargo.toml and a default binary crate.\nBinary crate root: src/main.rs.\nTo create a library crate, add a src/lib.rs.\nAn executable crate must have a main function as an entry point.\nA library crate can be used by other crates, and does not need a main entry point.",
    "crumbs": [
      "7. Managing Growing Projects with Packages, Crates, and Modules"
    ]
  },
  {
    "objectID": "slides/07-managing_growing_projects_with_packages_crates_and_modules.html#control-scope-and-privacy-with-modules",
    "href": "slides/07-managing_growing_projects_with_packages_crates_and_modules.html#control-scope-and-privacy-with-modules",
    "title": "7. Managing Growing Projects with Packages, Crates, and Modules",
    "section": "Control Scope and Privacy with Modules",
    "text": "Control Scope and Privacy with Modules\n\nCheck out the backyard example!",
    "crumbs": [
      "7. Managing Growing Projects with Packages, Crates, and Modules"
    ]
  },
  {
    "objectID": "slides/07-managing_growing_projects_with_packages_crates_and_modules.html#accessing-module-items",
    "href": "slides/07-managing_growing_projects_with_packages_crates_and_modules.html#accessing-module-items",
    "title": "7. Managing Growing Projects with Packages, Crates, and Modules",
    "section": "Accessing Module Items",
    "text": "Accessing Module Items\ncrate::front_of_house::hosting::add_to_waitlist();\n\nUse absolute paths starting with crate\n\nfront_of_house::hosting::add_to_waitlist();\n\nor, use relative paths starting with the module name",
    "crumbs": [
      "7. Managing Growing Projects with Packages, Crates, and Modules"
    ]
  },
  {
    "objectID": "slides/07-managing_growing_projects_with_packages_crates_and_modules.html#controlling-visibility",
    "href": "slides/07-managing_growing_projects_with_packages_crates_and_modules.html#controlling-visibility",
    "title": "7. Managing Growing Projects with Packages, Crates, and Modules",
    "section": "Controlling Visibility",
    "text": "Controlling Visibility\nmod front_of_house {\n    pub mod hosting {\n        pub fn add_to_waitlist() {}\n    }\n}\n\npub fn eat_at_restaurant() {\n    // Absolute path\n    crate::front_of_house::hosting::add_to_waitlist();\n\n    // Relative path\n    front_of_house::hosting::add_to_waitlist();\n}\n\nBy default, items are private\nUse pub to make modules, functions, and fields accessible",
    "crumbs": [
      "7. Managing Growing Projects with Packages, Crates, and Modules"
    ]
  },
  {
    "objectID": "slides/07-managing_growing_projects_with_packages_crates_and_modules.html#no-private-code-in-r",
    "href": "slides/07-managing_growing_projects_with_packages_crates_and_modules.html#no-private-code-in-r",
    "title": "7. Managing Growing Projects with Packages, Crates, and Modules",
    "section": "No private code in R",
    "text": "No private code in R\n\nIn R, everything is public\n\nEven un-exported functions can be accessed with :::.\n\nIn Rust, private items are not accessible outside their module.",
    "crumbs": [
      "7. Managing Growing Projects with Packages, Crates, and Modules"
    ]
  },
  {
    "objectID": "slides/07-managing_growing_projects_with_packages_crates_and_modules.html#simplify-paths",
    "href": "slides/07-managing_growing_projects_with_packages_crates_and_modules.html#simplify-paths",
    "title": "7. Managing Growing Projects with Packages, Crates, and Modules",
    "section": "Simplify Paths",
    "text": "Simplify Paths\nuse crate::front_of_house::hosting;\n\nhosting::add_to_waitlist();\n\nUse use to shorten paths.\nWorks within the scope it’s defined.",
    "crumbs": [
      "7. Managing Growing Projects with Packages, Crates, and Modules"
    ]
  },
  {
    "objectID": "slides/07-managing_growing_projects_with_packages_crates_and_modules.html#re-exporting-with-pub-use",
    "href": "slides/07-managing_growing_projects_with_packages_crates_and_modules.html#re-exporting-with-pub-use",
    "title": "7. Managing Growing Projects with Packages, Crates, and Modules",
    "section": "Re-exporting with pub use",
    "text": "Re-exporting with pub use\npub use crate::front_of_house::hosting;\n\nhosting::add_to_waitlist();\n\nMakes items available for external users.",
    "crumbs": [
      "7. Managing Growing Projects with Packages, Crates, and Modules"
    ]
  },
  {
    "objectID": "slides/07-managing_growing_projects_with_packages_crates_and_modules.html#splitting-modules",
    "href": "slides/07-managing_growing_projects_with_packages_crates_and_modules.html#splitting-modules",
    "title": "7. Managing Growing Projects with Packages, Crates, and Modules",
    "section": "Splitting Modules",
    "text": "Splitting Modules\n\nDefine a module in src/lib.rs:\n\nmod front_of_house;\n\nCreate src/front_of_house.rs:\n\npub mod hosting {\n    pub fn add_to_waitlist() {}\n}\n\nNest submodules in src/front_of_house/hosting.rs.",
    "crumbs": [
      "7. Managing Growing Projects with Packages, Crates, and Modules"
    ]
  },
  {
    "objectID": "slides/06-enums_and_pattern_matching.html#defining-an-enum",
    "href": "slides/06-enums_and_pattern_matching.html#defining-an-enum",
    "title": "6. Enums and Pattern Matching",
    "section": "Defining an Enum",
    "text": "Defining an Enum\nEnums are a way of saying that a value is one of a possible set of values.\nenum IpAddrKind {\n    V4,\n    V6,\n}\n\nlet four = IpAddrKind::V4;\nlet six = IpAddrKind::V6;\nEnums can have multiple variants of the same type.",
    "crumbs": [
      "6. Enums and Pattern Matching"
    ]
  },
  {
    "objectID": "slides/06-enums_and_pattern_matching.html#using-enums-with-structs",
    "href": "slides/06-enums_and_pattern_matching.html#using-enums-with-structs",
    "title": "6. Enums and Pattern Matching",
    "section": "Using Enums with Structs",
    "text": "Using Enums with Structs\nWe can define enums that hold data.\nfn main() {\nenum IpAddrKind {\n    V4,\n    V6,\n}\n\nstruct IpAddr {\n    kind: IpAddrKind,\n    address: String,\n}\n\nlet home = IpAddr {\n    kind: IpAddrKind::V4,\n    address: String::from(\"127.0.0.1\"),\n};\n\nlet loopback = IpAddr {\n    kind: IpAddrKind::V6,\n    address: String::from(\"::1\"),\n};\n}",
    "crumbs": [
      "6. Enums and Pattern Matching"
    ]
  },
  {
    "objectID": "slides/06-enums_and_pattern_matching.html#enums-with-data-inside-variants",
    "href": "slides/06-enums_and_pattern_matching.html#enums-with-data-inside-variants",
    "title": "6. Enums and Pattern Matching",
    "section": "Enums with Data Inside Variants",
    "text": "Enums with Data Inside Variants\nEnums can hold data in their variants.\nWe avoid needing a struct:\nfn main() {    \nenum IpAddr {\n    V4(String),\n    V6(String),\n}\n\nlet home = IpAddr::V4(String::from(\"127.0.0.1\"));\n\nlet loopback = IpAddr::V6(String::from(\"::1\"));\n}\n\nEach variant can hold different types of data.\nVariants are functions that constructs an instance of the enum.",
    "crumbs": [
      "6. Enums and Pattern Matching"
    ]
  },
  {
    "objectID": "slides/06-enums_and_pattern_matching.html#enums-vs.-structs",
    "href": "slides/06-enums_and_pattern_matching.html#enums-vs.-structs",
    "title": "6. Enums and Pattern Matching",
    "section": "Enums vs. Structs",
    "text": "Enums vs. Structs\n\n\n\n\nenums\nstructs\n\n\n\n\ntype\nmultiple\nsame\n\n\nmethod\nyes\nyes\n\n\nfunctions\n“variant”\nassociated",
    "crumbs": [
      "6. Enums and Pattern Matching"
    ]
  },
  {
    "objectID": "slides/06-enums_and_pattern_matching.html#enums-can-hold-complex-data",
    "href": "slides/06-enums_and_pattern_matching.html#enums-can-hold-complex-data",
    "title": "6. Enums and Pattern Matching",
    "section": "Enums can hold complex data",
    "text": "Enums can hold complex data\n\n\nEnums with other enums or structs:\nenum IpAddr {\n    V4(Ipv4Addr),\n    V6(Ipv6Addr),\n}\n\n\n\nEnums with different types\nenum Message {\n    Quit, // has no data\n    Move { x: i32, y: i32 }, // named fields like a struct\n    Write(String), // A string\n    ChangeColor(i32, i32, i32), // Multiple i32 values\n}",
    "crumbs": [
      "6. Enums and Pattern Matching"
    ]
  },
  {
    "objectID": "slides/06-enums_and_pattern_matching.html#methods-in-enums",
    "href": "slides/06-enums_and_pattern_matching.html#methods-in-enums",
    "title": "6. Enums and Pattern Matching",
    "section": "Methods in Enums",
    "text": "Methods in Enums\nWe can add methods to enums:\n\nimpl Message {\n    fn call(&self) {\n        // method body\n    }\n}\n\nlet m = Message::Write(String::from(\"hello\"));\nm.call();",
    "crumbs": [
      "6. Enums and Pattern Matching"
    ]
  },
  {
    "objectID": "slides/06-enums_and_pattern_matching.html#the-option-enum",
    "href": "slides/06-enums_and_pattern_matching.html#the-option-enum",
    "title": "6. Enums and Pattern Matching",
    "section": "The Option Enum",
    "text": "The Option Enum\nRust doesn’t have null.\nInstead, it uses the Option&lt;T&gt; enum to represent a value that may or may not be present.\n\nenum Option&lt;T&gt; {\n    None,\n    Some(T),\n}\nThis is used when a value might be missing or absent.",
    "crumbs": [
      "6. Enums and Pattern Matching"
    ]
  },
  {
    "objectID": "slides/06-enums_and_pattern_matching.html#using-option-enum",
    "href": "slides/06-enums_and_pattern_matching.html#using-option-enum",
    "title": "6. Enums and Pattern Matching",
    "section": "Using Option Enum",
    "text": "Using Option Enum\nfn main() {\nlet some_number = Some(5);\nlet some_char = Some('e');\n\nlet absent_number: Option&lt;i32&gt; = None;\n}",
    "crumbs": [
      "6. Enums and Pattern Matching"
    ]
  },
  {
    "objectID": "slides/06-enums_and_pattern_matching.html#the-match-control-flow-construct",
    "href": "slides/06-enums_and_pattern_matching.html#the-match-control-flow-construct",
    "title": "6. Enums and Pattern Matching",
    "section": "The match Control Flow Construct",
    "text": "The match Control Flow Construct\nThe match expression in Rust checks values against patterns, running code based on the match:\nenum Coin {\n    Penny,\n    Nickel,\n    Dime,\n    Quarter,\n}\n\nfn value_in_cents(coin: Coin) -&gt; u8 {\n    match coin {\n        Coin::Penny =&gt; 1,\n        Coin::Nickel =&gt; 5,\n        Coin::Dime =&gt; 10,\n        Coin::Quarter =&gt; 25,\n    }\n}",
    "crumbs": [
      "6. Enums and Pattern Matching"
    ]
  },
  {
    "objectID": "slides/06-enums_and_pattern_matching.html#matching-with-values-and-binding",
    "href": "slides/06-enums_and_pattern_matching.html#matching-with-values-and-binding",
    "title": "6. Enums and Pattern Matching",
    "section": "Matching with Values and Binding",
    "text": "Matching with Values and Binding\nWe can bind values inside match arms, which is how we extract values from enum variants:\n#[derive(Debug)] // so we can inspect the state in a minute\nenum UsState {\n    Alabama,\n    Alaska,\n    // --snip--\n}\n\nenum Coin {\n    Penny,\n    Nickel,\n    Dime,\n    Quarter(UsState),\n}\n\nfn value_in_cents(coin: Coin) -&gt; u8 {\n    match coin {\n        Coin::Penny =&gt; 1,\n        Coin::Nickel =&gt; 5,\n        Coin::Dime =&gt; 10,\n        Coin::Quarter(state) =&gt; {\n            println!(\"State quarter from {state:?}!\");\n            25\n        }\n    }\n}\nWhen we compare that value with each of the match arms, none of them match until we reach Coin::Quarter(state)",
    "crumbs": [
      "6. Enums and Pattern Matching"
    ]
  },
  {
    "objectID": "slides/06-enums_and_pattern_matching.html#matching-with-optiont",
    "href": "slides/06-enums_and_pattern_matching.html#matching-with-optiont",
    "title": "6. Enums and Pattern Matching",
    "section": "Matching with Option<T>",
    "text": "Matching with Option&lt;T&gt;\nHandling the Option enum using match:\nfn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {\n        match x {\n            None =&gt; None,\n            Some(i) =&gt; Some(i + 1),\n        }\n    }\n\n    let five = Some(5);\n    let six = plus_one(five);\n    let none = plus_one(None);\nIf the Option contains a value (Some(i)), we perform an operation on it. If it’s None, we return None.",
    "crumbs": [
      "6. Enums and Pattern Matching"
    ]
  },
  {
    "objectID": "slides/06-enums_and_pattern_matching.html#matches-are-exhaustive",
    "href": "slides/06-enums_and_pattern_matching.html#matches-are-exhaustive",
    "title": "6. Enums and Pattern Matching",
    "section": "Matches Are Exhaustive",
    "text": "Matches Are Exhaustive\nThe arms’ patterns must cover all possibilities. Consider this version of our plus_one function:\n    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {\n        match x {\n            Some(i) =&gt; Some(i + 1),\n        }\n    }\n    \nWe didn’t handle the None case, so this code will cause a bug.",
    "crumbs": [
      "6. Enums and Pattern Matching"
    ]
  },
  {
    "objectID": "slides/06-enums_and_pattern_matching.html#catch-all-patterns-and-_-placeholder",
    "href": "slides/06-enums_and_pattern_matching.html#catch-all-patterns-and-_-placeholder",
    "title": "6. Enums and Pattern Matching",
    "section": "Catch-All Patterns and _ Placeholder",
    "text": "Catch-All Patterns and _ Placeholder\nThe _ pattern can be used for values that we don’t care about:\n    let dice_roll = 9;\n    match dice_roll {\n        3 =&gt; add_fancy_hat(),\n        7 =&gt; remove_fancy_hat(),\n        other =&gt; move_player(other),\n    }\n\n    fn add_fancy_hat() {}\n    fn remove_fancy_hat() {}\n    fn move_player(num_spaces: u8) {}\nNote that we have to put the catch-all (other) arm last because the patterns are evaluated in order\n    let dice_roll = 9;\n    match dice_roll {\n        3 =&gt; add_fancy_hat(),\n        7 =&gt; remove_fancy_hat(),\n        _ =&gt; reroll(),\n    }\n\n    fn add_fancy_hat() {}\n    fn remove_fancy_hat() {}\n    fn reroll() {}\nThe _ matches any value but doesn’t bind it to a variable.",
    "crumbs": [
      "6. Enums and Pattern Matching"
    ]
  },
  {
    "objectID": "slides/06-enums_and_pattern_matching.html#how-matches-interact-with-ownership",
    "href": "slides/06-enums_and_pattern_matching.html#how-matches-interact-with-ownership",
    "title": "6. Enums and Pattern Matching",
    "section": "How Matches Interact with Ownership",
    "text": "How Matches Interact with Ownership\nWhen matching on enums with non-copyable types like String, ownership is transferred carefully.\nfn main() {\nlet opt: Option&lt;String&gt; = Some(String::from(\"Hello world\"));\n\nmatch opt {\n    Some(_) =&gt; println!(\"Some!\"),\n    None =&gt; println!(\"None!\")\n};\n\nprintln!(\"{:?}\", opt);\n}\nIf we replace Some(_) with a variable name, like Some(s), then the program will NOT compile:\nfn main() {\nlet opt: Option&lt;String&gt; = \n    Some(String::from(\"Hello world\"));\n\nmatch opt {\n    // _ became s\n    Some(s) =&gt; println!(\"Some: {}\", s),\n    None =&gt; println!(\"None!\")\n};\n\nprintln!(\"{:?}\", opt); // opt loses read and own permission\n}",
    "crumbs": [
      "6. Enums and Pattern Matching"
    ]
  },
  {
    "objectID": "slides/06-enums_and_pattern_matching.html#using-references-in-match",
    "href": "slides/06-enums_and_pattern_matching.html#using-references-in-match",
    "title": "6. Enums and Pattern Matching",
    "section": "Using References in match",
    "text": "Using References in match\nIf we want to avoid moving the data, we can match on a reference:\nfn main() {\nlet opt: Option&lt;String&gt; = Some(String::from(\"Hello world\"));\n\n// opt became &opt\nmatch &opt {\n    Some(s) =&gt; println!(\"Some: {}\", s),\n    None =&gt; println!(\"None!\")\n};\n\nprintln!(\"{:?}\", opt);  // This works because `opt` is borrowed.\n}",
    "crumbs": [
      "6. Enums and Pattern Matching"
    ]
  },
  {
    "objectID": "slides/06-enums_and_pattern_matching.html#concise-control-flow-with-if-let",
    "href": "slides/06-enums_and_pattern_matching.html#concise-control-flow-with-if-let",
    "title": "6. Enums and Pattern Matching",
    "section": "Concise Control Flow with if let",
    "text": "Concise Control Flow with if let\nif let provides a more concise way to handle enum variants in a control flow:\nFrom this: \n    let config_max = Some(3u8);\n    match config_max {\n        Some(max) =&gt; println!(\"The maximum is configured to be {max}\"),\n        _ =&gt; (),\n    }\nTo this:\n\nlet config_max = Some(3u8);\n\nif let Some(max) = config_max {\n    println!(\"The maximum is configured to be {max}\");\n}\nif let is less verbose than match but loses exhaustive checking.",
    "crumbs": [
      "6. Enums and Pattern Matching"
    ]
  },
  {
    "objectID": "slides/06-enums_and_pattern_matching.html#summary",
    "href": "slides/06-enums_and_pattern_matching.html#summary",
    "title": "6. Enums and Pattern Matching",
    "section": "Summary",
    "text": "Summary\n\nEnums to define types that can be one of several possible variants.\nPattern matching allos us to destructure and match on specific patterns.\nThe Option enum is used to safely handle cases where a value might be present or absent.",
    "crumbs": [
      "6. Enums and Pattern Matching"
    ]
  }
]